<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Echo Terminal · Stream Console</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #07070a;
      --panel: #05070c;
      --panel-strong: #161c26;
      --panel-ghost: rgba(36, 39, 43, 0.82);
      --border: rgba(74, 82, 90, 0.55);
      --border-soft: rgba(62, 120, 178, 0.32);
      --accent: #004ba8;
      --accent-alt: #3e78b2;
      --accent-soft: rgba(62, 120, 178, 0.2);
      --accent-strong: rgba(0, 75, 168, 0.45);
      --success: #2dd4bf;
      --warn: #fbbf24;
      --error: #f87171;
      --text: #f3f6ff;
      --text-muted: #97a3ba;
      --mono: 'JetBrains Mono', monospace;
      --glow: rgba(0, 75, 168, 0.3);
      --gradient-radial: radial-gradient(135% 160% at 50% 0%, rgba(62, 120, 178, 0.24), rgba(7, 7, 10, 0.92));
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--gradient-radial), var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      height: 72px;
      background: linear-gradient(135deg, rgba(36, 39, 43, 0.95), rgba(7, 7, 10, 0.94));
      border-bottom: 1px solid rgba(62, 120, 178, 0.28);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 32px;
      padding: 0 36px;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 14px 40px rgba(4, 6, 12, 0.6);
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .brand h1 {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .brand span {
      font-size: 13px;
      color: rgba(247, 249, 255, 0.65);
    }

    .nav-link {
      appearance: none;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-muted);
      font-size: 14px;
      font-weight: 500;
      padding: 8px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.18s ease;
    }

    .nav-link:hover {
      color: var(--text);
      border-color: rgba(0, 75, 168, 0.4);
    }

    .nav-link.active {
      color: var(--text);
      background: var(--accent-soft);
      border-color: var(--accent-strong);
      box-shadow: 0 12px 24px rgba(0, 75, 168, 0.25);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-left: auto;
    }

    .toolbar button,
    .toolbar a {
      border: 1px solid rgba(62, 120, 178, 0.28);
      background: rgba(36, 39, 43, 0.78);
      color: var(--text);
      font-size: 13px;
      padding: 8px 14px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      text-decoration: none;
      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
    }

    .toolbar a {
      text-decoration: none;
    }

    .toolbar button.primary {
      background: linear-gradient(135deg, rgba(0, 75, 168, 0.85), rgba(62, 120, 178, 0.85));
      border-color: rgba(0, 75, 168, 0.45);
      box-shadow: 0 14px 38px rgba(0, 75, 168, 0.35);
    }

    .toolbar button:hover,
    .toolbar a:hover {
      transform: translateY(-1px);
      border-color: rgba(0, 75, 168, 0.45);
      background: rgba(36, 39, 43, 0.92);
    }

    .toolbar button.primary:hover {
      transform: translateY(-2px);
    }

    main {
      flex: 1;
      display: flex;
      gap: 28px;
      padding: 36px;
      min-height: 0;
    }

    .left-pane {
      width: 360px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 22px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 24px 60px rgba(4, 6, 12, 0.55);
      height: calc(100vh - 72px - 72px);
      max-height: calc(100vh - 72px - 72px);
      min-height: 0;
    }

    .session-list {
      padding: 22px 22px 18px;
      border-bottom: 1px solid rgba(62, 120, 178, 0.16);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-list h2 {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(247, 249, 255, 0.75);
    }

    #sessionNewBtn {
      border: 1px solid rgba(62,120,178,0.32);
      background: rgba(62,120,178,0.18);
      color: var(--accent);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    #sessionNewBtn:hover {
      background: rgba(62,120,178,0.26);
    }

    .sessions {
      flex: 0 0 auto;
      max-height: 220px;
      overflow-y: auto;
      padding: 18px 22px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .session-item {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(62,120,178,0.18);
      background: rgba(36, 39, 43, 0.7);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
    }

    .session-item:hover,
    .session-item.active {
      transform: translateY(-2px);
      border-color: rgba(0,75,168,0.38);
      background: rgba(62,120,178,0.22);
    }

    .session-item span {
      font-size: 12px;
      color: var(--text-muted);
    }

    .session-empty {
      padding: 32px 0;
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .chat-log {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding: 22px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      border-top: 1px solid rgba(62, 120, 178, 0.14);
      border-bottom: 1px solid rgba(62, 120, 178, 0.14);
      background: rgba(24, 29, 38, 0.7);
    }

    .chat-msg {
      display: flex;
      gap: 10px;
      font-size: 13px;
      animation: fadeIn 0.12s ease-out;
    }

    .chat-msg.agent {
      flex-direction: row;
    }

    .chat-msg.user {
      flex-direction: row-reverse;
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: 10px;
      display: grid;
      place-items: center;
      background: var(--accent-soft);
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing: 0.08em;
      color: var(--accent);
    }

    .chat-msg.agent .avatar {
      background: rgba(0,75,168,0.45);
      color: #f2f7ff;
    }

    .bubble {
      max-width: 82%;
      background: rgba(24, 29, 38, 0.95);
      border: 1px solid rgba(62, 120, 178, 0.22);
      border-radius: 14px;
      padding: 12px 14px;
      line-height: 1.58;
      color: var(--text);
      box-shadow: 0 10px 28px rgba(4, 6, 12, 0.45);
    }

    .chat-msg.user .bubble {
      background: rgba(0,75,168,0.18);
      border-color: rgba(0,75,168,0.32);
      color: #e7f0ff;
    }

    .chat-input {
      padding: 18px 22px 22px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: rgba(20, 25, 33, 0.88);
      flex-shrink: 0;
    }

    .chat-input textarea {
      min-height: 70px;
      resize: none;
      border-radius: 14px;
      background: rgba(14, 18, 26, 0.9);
      border: 1px solid rgba(62,120,178,0.24);
      color: var(--text);
      padding: 12px 14px;
      font-size: 13px;
      line-height: 1.6;
    }

    .chat-input textarea:focus {
      outline: none;
      border-color: rgba(0,75,168,0.5);
      box-shadow: 0 0 0 1px rgba(0,75,168,0.2);
      background: rgba(20, 26, 36, 0.95);
    }

    .chat-input button {
      align-self: flex-end;
      border-radius: 12px;
      border: 1px solid rgba(62,120,178,0.32);
      background: rgba(62,120,178,0.22);
      color: #e2ecff;
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .chat-input button:hover {
      background: rgba(62,120,178,0.32);
    }

    .detail-pane {
      flex: 1;
      background: var(--panel-strong);
      border: 1px solid var(--border);
      border-radius: 24px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 24px 60px rgba(4, 6, 12, 0.55);
    }

    .detail-header {
      padding: 26px 30px;
      border-bottom: 1px solid rgba(62,120,178,0.18);
      background: rgba(24, 29, 38, 0.9);
      display: flex;
      justify-content: space-between;
      gap: 32px;
      align-items: flex-start;
    }

    .detail-header .summary {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .detail-header h2 {
      font-size: 24px;
      font-weight: 600;
      letter-spacing: -0.015em;
    }

    .detail-header .summary div {
      display: flex;
      gap: 18px;
      font-size: 13px;
      color: var(--text-muted);
      flex-wrap: wrap;
    }

    .detail-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 12px;
    }

    .detail-controls .streams-actions button {
      padding: 6px 14px;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: var(--mono);
      font-size: 12px;
      padding: 7px 14px;
      border-radius: 999px;
      border: 1px solid var(--accent-strong);
      background: var(--accent-soft);
      color: #f1f7ff;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .status-pill.warn {
      background: rgba(245, 158, 11, 0.18);
      border-color: rgba(245, 158, 11, 0.38);
      color: #fde68a;
    }

    .status-pill.error {
      background: rgba(248, 113, 113, 0.18);
      border-color: rgba(248, 113, 113, 0.38);
      color: #fecdd3;
    }

    .detail-body {
      padding: 28px 30px 32px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 22px;
      align-items: start;
      overflow-y: auto;
      max-height: calc(100vh - 72px - 110px);
      background: rgba(11, 14, 20, 0.88);
    }

    .panel {
      background: rgba(19, 23, 31, 0.95);
      border: 1px solid rgba(62,120,178,0.22);
      border-radius: 20px;
      padding: 22px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 18px 44px rgba(4, 6, 12, 0.45);
    }

    .panel h3 {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #d8e5f5;
    }

    .panel dl {
      display: grid;
      grid-template-columns: minmax(120px, 0.4fr) 1fr;
      row-gap: 12px;
      column-gap: 14px;
      font-size: 13px;
    }

    .panel dt {
      color: var(--text-muted);
      font-family: var(--mono);
      letter-spacing: 0.02em;
    }

    .panel dd {
      font-family: var(--mono);
      color: #e5e9ff;
    }

    .source-schema-block {
      border: 1px solid rgba(62,120,178,0.2);
      border-radius: 16px;
      padding: 14px 16px;
      background: rgba(8, 12, 18, 0.72);
      margin-top: 12px;
    }

    .source-schema-title {
      font-size: 13px;
      font-weight: 600;
      color: #f1f5ff;
      margin-bottom: 10px;
    }

    .source-schema-grid {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
    }

    .source-schema-field {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(62,120,178,0.12);
    }

    .source-schema-field:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .source-schema-field span:first-child {
      font-family: var(--mono);
      color: #e0e7ff;
    }

    .source-schema-field span:last-child {
      color: #c3cfe4;
      text-align: right;
    }

    .pm-step {
      margin-top: 10px;
      font-size: 13px;
      color: #cbd5f5;
    }

    .pm-text-list {
      margin-top: 12px;
      padding-left: 20px;
      font-size: 13px;
      color: #e2e8f0;
      line-height: 1.5;
    }

    .pm-text-list li {
      margin-bottom: 10px;
    }

    .pm-event-extra {
      font-size: 12px;
      color: #94a3b8;
      display: block;
    }

    .pm-instructions {
      margin-top: 14px;
      font-size: 12px;
      color: #cbd5f5;
    }

    .code-block {
      background: rgba(14, 18, 26, 0.95);
      border: 1px solid rgba(62,120,178,0.22);
      border-radius: 14px;
      padding: 14px 0 0;
      position: relative;
      overflow: hidden;
    }

    .code-block button {
      position: absolute;
      top: 12px;
      right: 12px;
      border: 1px solid rgba(62,120,178,0.35);
      background: rgba(62,120,178,0.18);
      color: #e0ecff;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 11px;
      cursor: pointer;
    }

    .code-block pre {
      margin: 0;
      padding: 20px 20px 18px;
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.6;
      color: #d4e1f3;
    }

    .code-block .kw { color: #9ac7ff; }
    .code-block .const { color: #f9a8d4; }
    .code-block .str { color: #bef264; }
    .code-block .cmd { color: #facc15; }
    .code-block .flag { color: #fca5a5; }
    .code-block .comment { color: #8695ad; }

    .actions-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .action-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid rgba(62,120,178,0.28);
      background: rgba(24, 29, 38, 0.82);
      padding: 12px 16px;
      border-radius: 14px;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.15s ease, border-color 0.15s ease;
    }

    .action-btn:hover {
      background: rgba(62,120,178,0.24);
      transform: translateY(-1px);
    }

    .action-btn.danger {
      border-color: rgba(248,113,113,0.45);
      background: rgba(127, 29, 29, 0.28);
      color: #fecaca;
    }

    .column-merge {
      grid-column: 1 / -1;
    }

    .streams-view {
      display: none;
      flex-direction: column;
      flex: 1;
      gap: 24px;
      background: rgba(11, 14, 20, 0.78);
      border: 1px solid var(--border);
      border-radius: 24px;
      padding: 32px;
      box-shadow: 0 24px 60px rgba(4, 6, 12, 0.5);
    }

    .streams-hero {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .streams-hero h2 {
      font-size: 24px;
      font-weight: 600;
      letter-spacing: -0.015em;
    }

    .streams-hero-headline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .streams-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .streams-actions button {
      border: 1px solid rgba(62,120,178,0.32);
      background: rgba(62,120,178,0.16);
      color: #e0ecff;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .streams-actions button:hover {
      background: rgba(62,120,178,0.26);
    }

    .streams-hero p {
      font-size: 14px;
      color: var(--text-muted);
      max-width: 560px;
    }

    .streams-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px;
    }

    .stream-card {
      border: 1px solid rgba(62,120,178,0.24);
      background: rgba(24, 29, 38, 0.82);
      border-radius: 20px;
      padding: 22px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
      box-shadow: 0 18px 44px rgba(4, 6, 12, 0.45);
    }

    .stream-card:hover {
      transform: translateY(-4px);
      border-color: rgba(0,75,168,0.45);
      background: rgba(36, 42, 52, 0.92);
    }

    .stream-card.active {
      border-color: rgba(0,75,168,0.55);
      box-shadow: 0 20px 48px rgba(0,75,168,0.28);
    }

    .stream-card header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
    }

    .stream-card header h3 {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .stream-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .stream-meta span {
      display: block;
    }

    .stream-card footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .stream-card footer button {
      border: 1px solid rgba(62,120,178,0.35);
      background: rgba(62,120,178,0.22);
      color: #e0ecff;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .stream-empty {
      padding: 40px 24px;
      border: 1px dashed rgba(62,120,178,0.3);
      border-radius: 18px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }

    body.view-chat main {
      justify-content: flex-start;
      align-items: stretch;
    }

    body.view-chat .left-pane {
      width: 100%;
      max-width: none;
      flex: 1;
      border-radius: 28px;
      border: 1px solid rgba(62,120,178,0.28);
    }

    body.view-chat .session-list,
    body.view-chat .sessions {
      display: none;
    }

    body.view-chat .chat-log {
      flex: 1;
      min-height: 420px;
      max-height: none;
      border-radius: 18px;
    }

    body.view-chat .chat-input {
      border-radius: 0 0 28px 28px;
    }

    body.view-chat .detail-pane {
      display: none;
    }

    body.view-chat #streamsView {
      display: none;
    }

    body.view-streams main {
      justify-content: center;
    }

    body.view-streams .left-pane,
    body.view-streams .detail-pane {
      display: none;
    }

    body.view-streams #streamsView {
      display: flex;
      max-width: 1100px;
    }

    body.view-stream-detail #streamsView {
      display: none;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 1200px) {
      header {
        flex-wrap: wrap;
        height: auto;
        padding: 16px 24px;
        gap: 16px;
      }

      .toolbar {
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      main {
        flex-direction: column;
        padding: 24px;
      }

      .left-pane {
        width: 100%;
      }

      .detail-pane {
        width: 100%;
      }

      .detail-body {
        grid-template-columns: 1fr;
      }

      body.view-streams #streamsView {
        max-width: none;
      }
    }

    @media (max-width: 768px) {
      .toolbar {
        width: 100%;
        justify-content: center;
      }

      .toolbar button,
      .toolbar a {
        flex: 1;
        justify-content: center;
      }

      .streams-grid {
        grid-template-columns: 1fr;
      }

      .chat-log {
        max-height: none;
      }
    }
  </style>
</head>
<body class="view-chat">
  <header>
    <div class="brand">
      <h1>3KKO</h1>
    </div>
    <div class="toolbar">
      <button class="nav-link active" id="navChat">Chat</button>
      <button class="nav-link" id="navStreams">Streams</button>
      <button class="nav-link" id="navHistory">History</button>
      <a class="nav-link" href="https://docs.example.com" target="_blank" rel="noreferrer">Docs</a>
      <button class="primary" id="toolbarNew">New Stream</button>
      <div id="auth-status" style="margin-left: 16px; display: none; position: relative;">
        <button id="user-email-display" style="border: 1px solid rgba(148,163,184,0.25); background: rgba(148,163,184,0.08); color: var(--text-muted); font-size: 13px; padding: 8px 12px; border-radius: 8px; cursor: pointer; transition: all 0.2s;">
          user@example.com
        </button>
        <div id="user-dropdown" style="display: none; position: absolute; top: calc(100% + 8px); right: 0; min-width: 220px; background: rgba(22, 28, 38, 0.98); border: 1px solid rgba(59,130,246,0.25); border-radius: 12px; padding: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index: 1000;">
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <div style="display: flex; align-items: center; justify-content: space-between; padding: 4px 0;">
              <span style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Tier</span>
              <span id="tier-badge" style="font-size: 11px; padding: 4px 8px; border-radius: 6px; background: rgba(59,130,246,0.15); color: #60a5fa; font-weight: 600; text-transform: uppercase;">Free</span>
            </div>
            <div style="display: flex; align-items: center; justify-content: space-between; padding: 4px 0;">
              <span style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Active Streams</span>
              <span id="streams-count" style="color: var(--text); font-size: 12px; font-weight: 500;">0/5</span>
            </div>
            <div style="display: flex; align-items: center; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid rgba(148,163,184,0.15); padding-bottom: 8px;">
              <span style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">This Month</span>
              <span id="monthly-count" style="color: var(--text); font-size: 12px; font-weight: 500;">0</span>
            </div>
            <button id="logout-btn" style="margin-top: 4px; border: 1px solid rgba(248,113,113,0.35); background: rgba(248,113,113,0.12); color: #fca5a5; font-size: 12px; padding: 8px 12px; border-radius: 8px; cursor: pointer; width: 100%; transition: all 0.2s;">Sign Out</button>
          </div>
        </div>
      </div>
      <a id="login-link" href="/login" style="margin-left: 16px; display: none; border: 1px solid rgba(59,130,246,0.35); background: rgba(59,130,246,0.15); color: var(--text); font-size: 13px; padding: 6px 12px; border-radius: 8px; text-decoration: none;">Sign In</a>
    </div>
  </header>

  <main>
    <aside class="left-pane">
      <div class="session-list">
        <h2>Streams</h2>
        <button id="sessionNewBtn">New</button>
      </div>
      <div class="sessions" id="sessionList"></div>
      <div class="chat-log" id="chatLog"></div>
      <form class="chat-input" id="chatForm">
        <textarea id="messageInput" placeholder="Ask Echo Agent to create or modify streams…" rows="4"></textarea>
        <button type="submit">Submit</button>
      </form>
    </aside>

    <section class="detail-pane" id="detailPane">
      <div class="detail-header" id="streamHeader">
        <div class="summary">
          <h2>Select a stream to view details</h2>
          <div style="display:flex;gap:18px;font-size:13px;color:var(--text-muted);">
            <span>No stream loaded</span>
          </div>
        </div>
        <div class="detail-controls">
          <div class="streams-actions detail-actions">
            <button data-action="pause-all">Pause All</button>
          </div>
          <span class="status-pill" id="streamStatus" style="display:none;">• LIVE</span>
        </div>
      </div>
      <div class="detail-body" id="detailBody">
        <div class="panel column-merge" style="text-align:center;opacity:0.6;">
          <h3 style="margin-bottom:10px;">Awaiting Selection</h3>
          <p style="font-size:13px;color:var(--text-muted);">
            Use Echo Agent to launch a stream or select one from the Sessions list to inspect its metadata, schema, integrations, and performance metrics.
          </p>
        </div>
      </div>
    </section>
    <section class="streams-view" id="streamsView">
      <div class="streams-hero">
        <div class="streams-hero-headline">
          <h2>Active Streams</h2>
          <div class="streams-actions">
            <button data-action="pause-all">Pause All</button>
          </div>
        </div>
        <p>Launch new streams from the chat, then jump back in here to inspect performance and metadata.</p>
      </div>
      <div class="streams-grid" id="streamsDirectory"></div>
    </section>

    <section class="streams-view" id="historyView" style="display: none;">
      <div class="streams-hero">
        <div class="streams-hero-headline">
          <h2>Stream History</h2>
        </div>
        <p>View all streams you've created and their current status.</p>
      </div>
      <div id="historyContent" style="padding: 20px;">
        <div id="historyList" style="display: flex; flex-direction: column; gap: 12px;"></div>
      </div>
    </section>
  </main>

  <script>
    const chatLog = document.getElementById('chatLog');
    const chatForm = document.getElementById('chatForm');
    const messageInput = document.getElementById('messageInput');
    const sessionList = document.getElementById('sessionList');
    const detailHeader = document.getElementById('streamHeader');
    const headerSummary = detailHeader.querySelector('.summary');
    const detailBody = document.getElementById('detailBody');
    const streamStatus = document.getElementById('streamStatus');
    const streamsView = document.getElementById('streamsView');
    const streamsDirectory = document.getElementById('streamsDirectory');
    const navChat = document.getElementById('navChat');
    const navStreams = document.getElementById('navStreams');
    const root = document.body;
    const VIEW_CHAT = 'chat';
    const VIEW_STREAMS = 'streams';
    const VIEW_HISTORY = 'history';
    const VIEW_DETAIL = 'stream-detail';
    const DEX_DEFAULT_INTERVAL_SEC = 2;
    const viewClasses = ['view-chat', 'view-streams', 'view-history', 'view-stream-detail'];

    const activeStreams = new Map();
    let currentStreamId = null;
    let pauseAll = false;

    function escapeHtml(str = '') {
      return str.replace(/[&<>"]+/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]));
    }

    function setView(nextView) {
      if (![VIEW_CHAT, VIEW_STREAMS, VIEW_HISTORY, VIEW_DETAIL].includes(nextView)) {
        nextView = VIEW_CHAT;
      }
      currentView = nextView;
      root.classList.remove(...viewClasses);
      root.classList.add(`view-${nextView}`);

      // Hide all views
      document.getElementById('chatLog').parentElement.style.display = nextView === VIEW_CHAT ? 'flex' : 'none';
      document.getElementById('detailPane').style.display = nextView === VIEW_DETAIL ? 'block' : 'none';
      document.getElementById('streamsView').style.display = nextView === VIEW_STREAMS ? 'block' : 'none';
      document.getElementById('historyView').style.display = nextView === VIEW_HISTORY ? 'block' : 'none';

      if (navChat) {
        navChat.classList.toggle('active', nextView === VIEW_CHAT);
      }
      if (navStreams) {
        navStreams.classList.toggle('active', nextView === VIEW_STREAMS || nextView === VIEW_DETAIL);
      }
      const navHistory = document.getElementById('navHistory');
      if (navHistory) {
        navHistory.classList.toggle('active', nextView === VIEW_HISTORY);
      }

      if (nextView === VIEW_STREAMS && streamsView) {
        streamsView.scrollTop = 0;
      }
      if (nextView === VIEW_CHAT && messageInput) {
        messageInput.focus({ preventScroll: true });
      }
      if (nextView === VIEW_HISTORY) {
        loadHistory();
      }
    }

    if (navChat) {
      navChat.addEventListener('click', (event) => {
        event.preventDefault();
        setView(VIEW_CHAT);
      });
    }

    if (navStreams) {
      navStreams.addEventListener('click', (event) => {
        event.preventDefault();
        setView(VIEW_STREAMS);
        renderStreamsDirectory();
      });
    }

    const navHistory = document.getElementById('navHistory');
    if (navHistory) {
      navHistory.addEventListener('click', (event) => {
        event.preventDefault();
        setView(VIEW_HISTORY);
      });
    }

    if (streamsDirectory) {
      streamsDirectory.addEventListener('click', (event) => {
        const target = event.target.closest('[data-stream]');
        if (!target) return;
        event.preventDefault();
        loadStream(target.dataset.stream);
      });
    }

    function appendMessage(role, html) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chat-msg ' + role;
      wrapper.innerHTML = `
        <div class="avatar">${role === 'agent' ? 'AI' : 'ME'}</div>
        <div class="bubble">${html}</div>
      `;
      chatLog.appendChild(wrapper);
      chatLog.scrollTop = chatLog.scrollHeight;
      return wrapper.querySelector('.bubble');
    }

    const pauseAllButtons = Array.from(document.querySelectorAll('[data-action="pause-all"]'));
    const pollTimers = new Map();
    let pendingPolymarketSelection = null;
    let pendingPolymarketTagPrompt = null;
    let pendingDexPreference = null;

    function setPauseButtonLabels() {
      pauseAllButtons.forEach(btn => {
        btn.textContent = pauseAll ? 'Resume All' : 'Pause All';
      });
    }

    pauseAllButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        pauseAll = !pauseAll;
        appendMessage('agent', pauseAll ? 'All streams paused (not yet implemented).' : 'Resume streams (not yet implemented).');
        setPauseButtonLabels();
      });
    });

    setPauseButtonLabels();

    function cloneSpec(spec) {
      if (!spec) return spec;
      try {
        return structuredClone(spec);
      } catch (err) {
        return JSON.parse(JSON.stringify(spec));
      }
    }

    function detectTokenPricePrompt(text) {
      if (!text) return null;
      const normalized = text.trim();
      if (!normalized) return null;
      const patterns = [
        /\bprice\s+(?:of|for)\s+\$?([a-z0-9]{2,12})\b/i,
        /\bget\s+(?:me\s+)?\$?([a-z0-9]{2,12})\s+price\b/i,
      ];
      for (const pattern of patterns) {
        const match = normalized.match(pattern);
        if (match && match[1]) {
          const symbol = match[1].replace(/[^a-z0-9]/gi, '').toUpperCase();
          if (symbol.length >= 2 && symbol.length <= 12) {
            return { symbol, original: match[0] };
          }
        }
      }
      const simple = normalized.match(/^\s*\$?([a-z0-9]{2,12})\s+price\b/i);
      if (simple && simple[1]) {
        const words = normalized.split(/\s+/);
        if (words.length <= 4) {
          const symbol = simple[1].replace(/[^a-z0-9]/gi, '').toUpperCase();
          if (symbol.length >= 2 && symbol.length <= 12) {
            return { symbol, original: simple[0] };
          }
        }
      }
      return null;
    }

    function detectMintAddress(text) {
      if (!text) return null;
      const normalized = text.trim();
      if (!normalized) return null;
      const keywordMatch = normalized.match(/\b(?:mint|token|contract|address)\s+([1-9A-HJ-NP-Za-km-z]{32,44})\b/);
      if (keywordMatch && keywordMatch[1]) {
        return { mint: keywordMatch[1], context: 'keyword' };
      }
      const standaloneMatch = normalized.match(/^([1-9A-HJ-NP-Za-km-z]{32,44})$/);
      if (standaloneMatch && standaloneMatch[1]) {
        return { mint: standaloneMatch[1], context: 'standalone' };
      }
      const genericMatch = normalized.match(/\b([1-9A-HJ-NP-Za-km-z]{32,44})\b/);
      if (genericMatch && genericMatch[1]) {
        const leadWords = normalized.slice(0, genericMatch.index).trim().split(/\s+/);
        const tailWords = normalized.slice(genericMatch.index + genericMatch[0].length).trim().split(/\s+/);
        if (leadWords.length <= 4 && tailWords.length <= 4) {
          return { mint: genericMatch[1], context: 'loose' };
        }
      }
      return null;
    }

    function formatMintPreview(mint) {
      if (!mint) return '';
      return mint.length > 12 ? `${mint.slice(0, 6)}…${mint.slice(-4)}` : mint;
    }

    function formatCompactNumber(value) {
      const num = Number(value);
      if (!Number.isFinite(num) || num === 0) return null;
      const abs = Math.abs(num);
      if (abs >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
      if (abs >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
      if (abs >= 1e3) return `${(num / 1e3).toFixed(2)}K`;
      return num.toFixed(2);
    }

    function describeBestReason(reason) {
      if (reason === 'highest_marketcap_and_volume') return 'highest marketcap & volume';
      if (reason === 'highest_marketcap') return 'highest marketcap';
      return 'top ranked token';
    }

    async function handleMintPrompt(prompt) {
      const detection = detectMintAddress(prompt);
      if (!detection) return false;
      pendingDexPreference = null;
      const preview = formatMintPreview(detection.mint);
      const bubble = appendMessage('agent', `Building decentralized price stream for mint ${escapeHtml(preview)}…`);
      await buildDexPriceFlow(
        {
          mint: detection.mint,
          userPrompt: prompt,
        },
        bubble
      );
      return true;
    }

    function buildCexSpec(flowState) {
      const availability = flowState?.availability || {};
      const preferredSymbol = availability.normalized_symbol || flowState.normalizedSymbol || `${flowState.symbol}/USDT`;
      const specSymbols = [preferredSymbol];
      const exchanges = Array.isArray(availability.exchanges) ? availability.exchanges : [];
      const source = {
        type: 'ccxt',
        symbols: specSymbols,
        fields: ['price', 'volume', 'bid', 'ask'],
        interval_sec: 1,
      };
      if (exchanges.length) {
        source.exchanges = exchanges.map(entry => entry.exchange);
        if (exchanges[0]?.exchange) {
          source.exchange = exchanges[0].exchange;
        }
      }
      if (availability.resolved_symbols) {
        source.resolved_symbols = availability.resolved_symbols;
      }
      return {
        symbols: specSymbols,
        interval_sec: 1,
        sources: [source],
      };
    }

    async function buildDexPriceFlow(flowState, existingBubble = null) {
      const descriptor = flowState.symbol
        || flowState.normalizedSymbol
        || (flowState.mint ? `mint ${formatMintPreview(flowState.mint)}` : 'token');
      const bubble = existingBubble || appendMessage('agent', `Searching Jupiter for ${escapeHtml(descriptor)}…`);
      const lookup = flowState.mint || flowState.symbol || flowState.normalizedSymbol;
      if (!lookup) {
        bubble.innerHTML = 'Need a token symbol or contract address.';
        return;
      }
      try {
        const response = await fetch(`/v1/jupiter/search?query=${encodeURIComponent(lookup)}`);
        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const tokens = Array.isArray(data.tokens) ? data.tokens : [];

        let best = null;
        if (flowState.mint) {
          best = tokens.find(token => token.id === flowState.mint) || null;
        }
        if (!best) {
          best = data.best_token || tokens[0] || null;
        }
        if (!best && flowState.mint) {
          best = {
            id: flowState.mint,
            contract: flowState.mint,
            symbol: flowState.symbol || flowState.normalizedSymbol || 'TOKEN',
            name: flowState.symbol || flowState.normalizedSymbol || 'Token',
          };
        }
        if (!best) {
          bubble.innerHTML = `No decentralized pools found for ${escapeHtml(descriptor)}.`;
          return;
        }

        const mint = flowState.mint || best.contract || best.id;
        if (!mint) {
          bubble.innerHTML = `No mint discovered for ${escapeHtml(descriptor)}.`;
          return;
        }

        const shortMint = formatMintPreview(mint);
        const rawTicker = best.symbol || flowState.symbol || flowState.normalizedSymbol || 'TOKEN';
        const sanitizedTicker = rawTicker.replace(/[^A-Za-z0-9/]/g, '').toUpperCase() || 'TOKEN';
        const pairLabel = sanitizedTicker.includes('/') ? sanitizedTicker : `${sanitizedTicker}/USDC`;
        const reasonCode = flowState.mint && best.id === flowState.mint ? 'provided_mint' : data.best_reason;
        const reason = reasonCode === 'provided_mint'
          ? 'provided contract address'
          : describeBestReason(reasonCode);
        const mcap = formatCompactNumber(best.mcap);
        const volume = formatCompactNumber(best.volume_24h);
        const details = [mcap ? `mcap ${mcap}` : null, volume ? `24h vol ${volume}` : null]
          .filter(Boolean)
          .join(' • ');

        bubble.innerHTML = `
          <div>Best Jupiter match: <strong>${escapeHtml(best.name || sanitizedTicker)}</strong> (${escapeHtml(sanitizedTicker)})</div>
          <div>Mint: <code>${escapeHtml(mint)}</code></div>
          <div>${escapeHtml(reason)}${details ? ` • ${escapeHtml(details)}` : ''}</div>
          <div style="margin-top:8px;">Building decentralized price stream…</div>
        `;

        const spec = {
          symbols: [pairLabel],
          interval_sec: DEX_DEFAULT_INTERVAL_SEC,
          sources: [
            {
              type: 'jupiter',
              mint,
              symbol: pairLabel,
              token_symbol: sanitizedTicker,
              token_name: best.name || sanitizedTicker,
              decimals: best.decimals,
              interval_sec: DEX_DEFAULT_INTERVAL_SEC,
            }
          ],
        };

        const parsed = {
          spec,
          reasoning: `Jupiter price stream for ${sanitizedTicker}`,
          parsed_config: {
            jupiter: {
              mint: mint,
              symbol: sanitizedTicker,
              compact_mint: shortMint,
              reason,
            },
          },
        };

        renderParseSummary(
          parsed,
          bubble,
          null,
          true,
          flowState.userPrompt || `Price of ${descriptor}`,
          true
        );
      } catch (err) {
        bubble.innerHTML = `Unable to source Jupiter price data: ${escapeHtml(err.message || 'unknown error')}`;
      }
    }

    async function maybeHandleTokenPricePrompt(prompt) {
      const detection = detectTokenPricePrompt(prompt);
      if (!detection) return false;

      const bubble = appendMessage('agent', `Checking ${escapeHtml(detection.symbol)} across exchanges…`);
      try {
        const response = await fetch(`/v1/markets/check?symbol=${encodeURIComponent(detection.symbol)}`);
        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const flowState = {
          symbol: detection.symbol,
          normalizedSymbol: data.normalized_symbol,
          userPrompt: prompt,
          availability: data,
        };

        if (data.listed) {
          const venues = data.exchanges
            .map(entry => entry.exchange?.toUpperCase())
            .filter(Boolean)
            .join(', ') || 'our CEX feed';
          bubble.innerHTML = `
            ${escapeHtml(detection.symbol)} is on ${escapeHtml(venues)}.<br>
            Would you like it <strong>on exchange</strong> or <strong>off exchange</strong>?
          `;
          pendingDexPreference = flowState;
        } else {
          bubble.innerHTML = `${escapeHtml(detection.symbol)} is not listed on our CEX feeds. Searching Jupiter…`;
          await buildDexPriceFlow(flowState, bubble);
        }
      } catch (err) {
        bubble.innerHTML = `Could not inspect ${escapeHtml(detection.symbol)}: ${escapeHtml(err.message || 'unknown error')}`;
      }
      return true;
    }

    async function handleDexPreferenceResponse(userInput) {
      if (!pendingDexPreference) return false;
      const answer = (userInput || '').trim().toLowerCase();
      if (!answer) {
        appendMessage('agent', 'Please reply with "on exchange" or "off exchange".');
        return true;
      }
      const flowState = pendingDexPreference;
      if (answer.includes('on')) {
        pendingDexPreference = null;
        const bubble = appendMessage('agent', `Configuring on-exchange stream for ${escapeHtml(flowState.symbol)}…`);
        const spec = buildCexSpec(flowState);
        const parsed = {
          spec,
          reasoning: `On-exchange price stream for ${flowState.symbol}`,
          parsed_config: {
            symbols: spec.symbols,
            exchanges: spec.sources[0]?.exchanges || [spec.sources[0]?.exchange].filter(Boolean),
          },
        };
        renderParseSummary(parsed, bubble, null, true, flowState.userPrompt || `${flowState.symbol} price`, true);
        return true;
      }

      if (answer.includes('off')) {
        pendingDexPreference = null;
        const bubble = appendMessage('agent', `Switching to decentralized price for ${escapeHtml(flowState.symbol)}…`);
        await buildDexPriceFlow(flowState, bubble);
        return true;
      }

      appendMessage('agent', 'Please reply with "on exchange" or "off exchange".');
      return true;
    }

    async function tryPolymarketPlan(prompt) {
      try {
        const response = await fetch('/v1/polymarket/plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: prompt }),
        });
        if (!response.ok) return null;
        const data = await response.json();
        if (!data.handled || !data.plan) return null;
        return data;
      } catch (err) {
        console.warn('polymarket plan failed', err);
        return null;
      }
    }

    function polymarketSourcesNeedingSelection(sources) {
      if (!Array.isArray(sources)) return [];
      return sources.filter(src =>
        src &&
        src.type === 'polymarket' &&
        (!Array.isArray(src.event_ids) || !src.event_ids.length)
      );
    }

    function polymarketSourcesMissingTag(sources) {
      if (!Array.isArray(sources)) return [];
      return sources.filter(src =>
        src &&
        src.type === 'polymarket' &&
        (!src.tag || !String(src.tag).trim())
      );
    }

    function isPolymarketIntent(text) {
      if (!text) return false;
      const lowered = text.toLowerCase();
      return lowered.includes('polymarket') || lowered.includes('prediction market');
    }

    function uniquePolymarketCategories(sources) {
      const set = new Set();
      sources.forEach(src => {
        (src?.categories || []).forEach(cat => {
          if (typeof cat === 'string' && cat.trim()) {
            set.add(cat.trim());
          }
        });
      });
      return Array.from(set);
    }

    function collectPolymarketTags(sources) {
      const tags = [];
      if (!Array.isArray(sources)) return tags;
      sources.forEach(src => {
        if (src?.type === 'polymarket' && src.tag && String(src.tag).trim()) {
          tags.push(String(src.tag).trim());
        }
      });
      return tags;
    }

    function promptPolymarketTag(parsed, bubble, preferredStreamId, forcedNew, userPrompt) {
      pendingPolymarketTagPrompt = {
        parsed,
        preferredStreamId,
        forcedNew,
        userPrompt,
      };
      bubble.innerHTML = `
        <div>Polymarket tag required.</div>
        <div class="pm-instructions" style="margin-top:6px;">
          Tell me the tag or topic label to narrow this search
          (example: <code>politics</code>, <code>sports</code>, <code>economy</code>).
        </div>
      `;
    }

    function renderPolymarketSelection(parsed, bubble, preferredStreamId, forcedNew, userPrompt, sourcesNeedingSelection) {
      pendingPolymarketSelection = null;
      bubble.innerHTML = `
        <div>Searching Polymarket for “${escapeHtml(userPrompt || 'your prompt')}”...</div>
        <div style="margin-top:8px;font-size:12px;color:#94a3b8;">Sit tight while I pull the latest markets.</div>
      `;

      const categories = uniquePolymarketCategories(sourcesNeedingSelection);
      const tags = collectPolymarketTags(sourcesNeedingSelection);
      const params = new URLSearchParams({ limit: '10' });
      if (userPrompt) {
        params.set('query', userPrompt);
      }
      categories.forEach(cat => params.append('category', cat));
      if (tags.length) {
        params.set('tag', tags[0]);
      }

      (async () => {
        try {
          const response = await fetch(`/v1/polymarket/search?${params.toString()}`);
          if (!response.ok) throw new Error(await response.text());
          const data = await response.json();
          const events = Array.isArray(data.events) ? data.events.slice(0, 10) : [];

          if (!events.length) {
            bubble.innerHTML = `
              <div>No Polymarket events matched “${escapeHtml(userPrompt || '')}”.</div>
              <div class="pm-instructions">Reply “skip” to stream all events or ask a different question.</div>
            `;
            pendingPolymarketSelection = {
              parsed,
              preferredStreamId,
              forcedNew,
              displayPrompt: userPrompt,
              events: []
            };
            return;
          }

          const listItems = events.map((evt, idx) => {
            const oi = typeof evt.open_interest === 'number' ? `$${Math.round(evt.open_interest)}` : '—';
            const vol = typeof evt.volume_24h === 'number' ? `$${Math.round(evt.volume_24h)}` : '—';
            const marketPreview = Array.isArray(evt.markets) && evt.markets.length
              ? evt.markets[0].question
              : '';
            return `
              <li>
                <strong>${idx + 1}) ${escapeHtml(evt.title || evt.slug || 'Untitled event')}</strong>
                <span class="pm-event-extra">Category: ${escapeHtml(evt.category || 'General')} · Open Interest: ${escapeHtml(oi)} · 24h Vol: ${escapeHtml(vol)}</span>
                ${marketPreview ? `<span class="pm-event-extra">Market: ${escapeHtml(marketPreview)}</span>` : ''}
              </li>
            `;
          }).join('');

          bubble.innerHTML = `
            <div class="pm-step"><strong>1) Polymarket stream question</strong><br/>${escapeHtml(userPrompt || '')}</div>
            <div class="pm-step"><strong>2) Matching events (top ${events.length})</strong></div>
            <ol class="pm-text-list">${listItems}</ol>
            <div class="pm-instructions">
              <strong>3) Reply</strong> with the event numbers you want (example: “1, 3, 5”). Type “skip” to include every event above.
              <br/>Once you reply, I’ll take care of <strong>step 4</strong> and launch the stream for those selections.
            </div>
          `;

          pendingPolymarketSelection = {
            parsed,
            preferredStreamId,
            forcedNew,
            displayPrompt: userPrompt,
            events
          };
        } catch (err) {
          bubble.innerHTML = `
            <div>Unable to fetch Polymarket events.</div>
            <div class="pm-instructions">Type “skip” to proceed without filtering or try another prompt.</div>
          `;
          pendingPolymarketSelection = {
            parsed,
            preferredStreamId,
            forcedNew,
            displayPrompt: userPrompt,
            events: []
          };
        }
      })();
    }

    function handlePolymarketSelectionResponse(userInput) {
      if (!pendingPolymarketSelection) return false;

      const pending = pendingPolymarketSelection;
      const trimmed = userInput.trim();
      if (!trimmed) {
        appendMessage('agent', 'Please reply with event numbers (e.g., "1 2 3") or type "skip".');
        return true;
      }

      const normalized = trimmed.toLowerCase();

      if (normalized.includes('skip') || normalized.includes('cancel') || normalized.includes('stop')) {
        pendingPolymarketSelection = null;
        appendMessage('agent', 'Skipping selection—streaming all matching Polymarket events.');
        const summaryBubble = appendMessage('agent', 'Building stream preview…');
        renderParseSummary(
          pending.parsed,
          summaryBubble,
          pending.preferredStreamId,
          pending.forcedNew,
          pending.displayPrompt || pending.userPrompt || '',
          true
        );
        return true;
      }

      if (!pending.events.length) {
        appendMessage('agent', 'No events are listed yet. Type "skip" to continue or start a new request.');
        return true;
      }

      const picks = Array.from(new Set(trimmed.match(/\d+/g)?.map(num => parseInt(num, 10)) || []))
        .filter(num => Number.isFinite(num) && num >= 1 && num <= pending.events.length);

      if (!picks.length) {
        appendMessage('agent', `Pick numbers between 1 and ${pending.events.length} (example: "1,4") or type "skip".`);
        return true;
      }

      const selected = picks
        .map(idx => pending.events[idx - 1])
        .filter(Boolean);
      const selectedIds = selected
        .map(evt => (typeof evt.event_id === 'string' && evt.event_id) || (typeof evt.slug === 'string' && evt.slug))
        .filter(Boolean);

      if (!selectedIds.length) {
        appendMessage('agent', 'Could not map those selections. Try different numbers or type "skip".');
        return true;
      }

      const updatedSpec = cloneSpec(pending.parsed.spec);
      if (!updatedSpec || !Array.isArray(updatedSpec.sources)) {
        appendMessage('agent', 'Spec is missing sources; please retry your request.');
        pendingPolymarketSelection = null;
        return true;
      }

      updatedSpec.sources = updatedSpec.sources.map(src => {
        if (
          src &&
          src.type === 'polymarket' &&
          (!Array.isArray(src.event_ids) || !src.event_ids.length)
        ) {
          return { ...src, event_ids: selectedIds };
        }
        return src;
      });

      const updatedParsed = { ...pending.parsed, spec: updatedSpec };
      appendMessage('agent', `4) Creating stream for selections ${picks.join(', ')}.`);
      pendingPolymarketSelection = null;
      const summaryBubble = appendMessage('agent', 'Building stream preview…');
      renderParseSummary(
        updatedParsed,
        summaryBubble,
        pending.preferredStreamId,
        pending.forcedNew,
        pending.displayPrompt || pending.userPrompt || '',
        true
      );
      return true;
    }

    function handlePolymarketTagResponse(userInput) {
      if (!pendingPolymarketTagPrompt) return false;
      const pending = pendingPolymarketTagPrompt;
      const tag = userInput.trim();
      if (!tag) {
        appendMessage('agent', 'Please provide a tag (e.g., "politics", "sports").');
        return true;
      }

      const updatedSpec = cloneSpec(pending.parsed.spec);
      if (!updatedSpec || !Array.isArray(updatedSpec.sources)) {
        appendMessage('agent', 'Spec is missing sources; please retry your request.');
        pendingPolymarketTagPrompt = null;
        return true;
      }

      updatedSpec.sources = updatedSpec.sources.map(src => {
        if (
          src &&
          src.type === 'polymarket' &&
          (!src.tag || !String(src.tag).trim())
        ) {
          return { ...src, tag: tag };
        }
        return src;
      });

      const updatedParsed = { ...pending.parsed, spec: updatedSpec };
      pendingPolymarketTagPrompt = null;
      const bubble = appendMessage('agent', `Using Polymarket tag “${escapeHtml(tag)}”.`);
      renderParseSummary(
        updatedParsed,
        bubble,
        pending.preferredStreamId,
        pending.forcedNew,
        pending.userPrompt || '',
        false
      );
      return true;
    }

    function getDefaultTargetStreamId() {
      if (currentStreamId && activeStreams.has(currentStreamId)) {
        return currentStreamId;
      }
      const iterator = activeStreams.keys();
      const first = iterator.next();
      return first.done ? null : first.value;
    }

    function shouldRequestNewStream(text) {
      const query = text.toLowerCase();
      return /\b(new|another|separate)\s+(stream|feed)\b/.test(query)
        || query.includes('create a new stream')
        || query.includes('start a new')
        || query.includes('spin up a new')
        || query.includes('brand new stream');
    }

    function applyStreamResponse(stream) {
      if (!stream || !stream.stream_id) return;
      const entry = activeStreams.get(stream.stream_id);
      if (!entry) {
        addSession(stream.stream_id, stream.ws_url, stream.spec);
        return;
      }
      entry.spec = cloneSpec(stream.spec);
      entry.wsUrl = stream.ws_url;
      entry.metrics = null;
      entry.schema = null;
      entry.derivedSchema = null;
      entry.lastEvent = null;
      entry.latencyHistory = [];
      entry.priceHistory = [];
      entry.createdAt = Date.now();
      entry.status = 'CONNECTING';
      if (entry.socket) {
        entry.socket.close();
        entry.socket = null;
      }
      openStreamSocket(entry);
      refreshMetrics(stream.stream_id);
      renderSessions();
      if (currentStreamId === stream.stream_id) {
        renderStreamDetail(entry);
      }
    }

    chatForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      const prompt = messageInput.value.trim();
      if (!prompt) return;

      appendMessage('user', escapeHtml(prompt));
      messageInput.value = '';

      if (pendingPolymarketSelection) {
        handlePolymarketSelectionResponse(prompt);
        return;
      }

      if (pendingPolymarketTagPrompt) {
        handlePolymarketTagResponse(prompt);
        return;
      }

      if (await handleDexPreferenceResponse(prompt)) {
        return;
      }

      pendingPolymarketSelection = null;
      pendingPolymarketTagPrompt = null;

      if (await handleMintPrompt(prompt)) {
        return;
      }

      if (await maybeHandleTokenPricePrompt(prompt)) {
        return;
      }

      const wantsNewStream = shouldRequestNewStream(prompt);
      const targetStreamId = wantsNewStream ? null : getDefaultTargetStreamId();
      const isEditingExisting = Boolean(targetStreamId && !wantsNewStream);
      const payload = { query: prompt };
      if (!isEditingExisting && targetStreamId) {
        payload.stream_id = targetStreamId;
      }

      const pending = appendMessage('agent', `Parsing “${escapeHtml(prompt)}”…`);

      if (isPolymarketIntent(prompt)) {
        pending.innerHTML = 'Polymarket streams are coming soon!';
        return;
      }
      try {
        if (!isEditingExisting) {
          const polymarketPlan = await tryPolymarketPlan(prompt);
          if (polymarketPlan) {
            const displayPrompt = polymarketPlan.search_query || prompt;
            renderParseSummary(polymarketPlan.plan, pending, targetStreamId, wantsNewStream, displayPrompt);
            return;
          }
        }

        const endpoint = isEditingExisting && targetStreamId
          ? `/v1/streams/${targetStreamId}/edit`
          : '/v1/streams/parse';

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!response.ok) throw new Error(await response.text());
        const parsed = await response.json();
        renderParseSummary(parsed, pending, targetStreamId, wantsNewStream, prompt);
      } catch (err) {
        pending.innerHTML = `
          <div>Error parsing request.</div>
          <div style="margin-top:8px;color:#fca5a5;font-size:13px;">${escapeHtml(err.message)}</div>
        `;
      }
    });

    function renderParseSummary(parsed, bubble, preferredStreamId = null, forcedNew = false, userPrompt = '', skipPolymarketPrompt = false) {
      const spec = parsed.spec || { sources: [], symbols: [], interval_sec: 1 };
      const sources = Array.isArray(spec.sources) ? spec.sources : [];
      const ccxtSources = sources.filter(src => src.type === 'ccxt');
      const otherSources = sources.filter(src => src.type !== 'ccxt');
      const polymarketMissingTag = polymarketSourcesMissingTag(sources);
      const pendingPolymarket = polymarketSourcesNeedingSelection(sources);

      if (polymarketMissingTag.length && !skipPolymarketPrompt) {
        promptPolymarketTag(parsed, bubble, preferredStreamId, forcedNew, userPrompt);
        return;
      }

      if (pendingPolymarket.length && !skipPolymarketPrompt) {
        renderPolymarketSelection(parsed, bubble, preferredStreamId, forcedNew, userPrompt, pendingPolymarket);
        return;
      }

      let targetStreamId = preferredStreamId && activeStreams.has(preferredStreamId)
        ? preferredStreamId
        : null;
      if (!targetStreamId && !forcedNew) {
        targetStreamId = getDefaultTargetStreamId();
      }
      const allowUpdate = Boolean(targetStreamId && activeStreams.has(targetStreamId) && !forcedNew);
      const targetStream = allowUpdate ? activeStreams.get(targetStreamId) : null;
      const targetLabel = targetStream
        ? ` (${escapeHtml((targetStream.spec.symbols || []).join(', ') || targetStreamId.slice(0, 8))})`
        : '';

      const rows = ccxtSources.map(src => `
        <tr>
          <td>${escapeHtml((src.exchange || 'BINANCEUS').toUpperCase())}</td>
          <td>${escapeHtml((src.symbols || []).join(', '))}</td>
          <td>${escapeHtml((src.fields || []).join(', ') || 'price, volume')}</td>
        </tr>
      `).join('');

      const otherRows = otherSources.map(src => {
        let detail = '';
        if (src.type === 'nitter') {
          const handle = src.username ? `@${src.username}` : 'nitter feed';
          const cadence = src.interval_sec ? `${src.interval_sec}s` : `${spec.interval_sec || 1}s`;
          detail = `${handle}, refresh ${cadence}`;
        } else if (src.type === 'google_trends') {
          const keywords = (src.keywords || []).join(', ') || 'auto keywords';
          const timeframe = src.timeframe || 'default window';
          detail = `keywords: ${keywords} • timeframe: ${timeframe}`;
        } else if (src.type === 'polymarket') {
          const events = (src.event_ids || []).join(', ') || 'all events';
          const categories = (src.categories || []).join(', ') || 'all categories';
          const cadence = src.interval_sec ? `${src.interval_sec}s` : `${spec.interval_sec || 1}s`;
          const visibility = `${events} • ${categories}`;
          const flags = [
            `refresh ${cadence}`,
            src.include_closed ? 'includes closed events' : null,
          ].filter(Boolean).join(' • ');
          detail = `${visibility}${flags ? ` • ${flags}` : ''}`;
        } else if (src.type === 'jupiter') {
          const mint = src.mint || src.contract || 'mint';
          const shortMint = mint.length > 12 ? `${mint.slice(0, 6)}...${mint.slice(-4)}` : mint;
          const cadence = src.interval_sec ? `${src.interval_sec}s` : `${spec.interval_sec || 1}s`;
          const label = src.token_name || src.symbol || 'Jupiter token';
          detail = `${label} • mint ${shortMint} • refresh ${cadence}`;
        } else {
          detail = Object.entries(src)
            .filter(([key]) => key !== 'type')
            .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(', ') : value}`)
            .join(' • ') || 'No extra config';
        }
        return `
          <tr>
            <td>${escapeHtml(src.type || 'custom')}</td>
            <td>${escapeHtml(detail)}</td>
          </tr>
        `;
      }).join('');

      const ccxtTable = ccxtSources.length ? `
        <table style="margin-top:12px;border-collapse:collapse;width:100%;font-size:12px;">
          <thead>
            <tr style="background:rgba(62,120,178,0.18);">
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Exchange</th>
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Symbols</th>
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Fields</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      ` : '';

      const updateNote = allowUpdate
        ? `<div style="margin-top:8px;font-size:12px;color:#9fb3d4;">
            Applying changes to stream <code>${escapeHtml(targetStreamId)}</code>${targetLabel}.
            Choose “Create New Stream” to start a separate feed.
          </div>`
        : '';

      bubble.innerHTML = `
        <div>Here’s the stream I can create:</div>
        ${updateNote}
        ${ccxtTable || ''}
        ${!ccxtTable ? '<div style="margin-top:12px;font-size:12px;color:#94a3b8;">No CCXT exchange sources configured.</div>' : ''}
        ${otherSources.length ? `
          <div style="margin-top:16px;font-size:12px;color:#c3cfe4;">Additional sources</div>
          <table style="margin-top:6px;border-collapse:collapse;width:100%;font-size:12px;">
            <thead>
              <tr style="background:rgba(62,120,178,0.12);">
                <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Type</th>
                <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Details</th>
              </tr>
            </thead>
            <tbody>${otherRows}</tbody>
          </table>
        ` : ''}
        <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
          ${allowUpdate ? '<button id="updateStreamBtn" style="border:1px solid rgba(16,185,129,0.45);background:rgba(16,185,129,0.18);color:#d1fae5;padding:8px 12px;border-radius:12px;font-size:12px;cursor:pointer;">Update Stream</button>' : ''}
          <button id="createStreamBtn" style="border:1px solid rgba(0,75,168,0.4);background:rgba(0,75,168,0.22);color:#e0ecff;padding:8px 12px;border-radius:12px;font-size:12px;cursor:pointer;">${allowUpdate ? 'Create New Stream' : 'Launch Stream'}</button>
          <button id="cancelLaunchBtn" style="border:1px solid rgba(148,163,184,0.3);background:rgba(148,163,184,0.12);color:#c3cfe4;padding:8px 12px;border-radius:12px;font-size:12px;cursor:pointer;">Modify</button>
        </div>
      `;

      const createBtn = bubble.querySelector('#createStreamBtn');
      if (createBtn) {
        createBtn.addEventListener('click', async () => {
          bubble.innerHTML = 'Launching stream…';
          try {
            // Get auth token if available
            const { data: { session } } = await supabase.auth.getSession();
            const headers = { 'Content-Type': 'application/json' };
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            const response = await fetch('/v1/streams', {
              method: 'POST',
              headers,
              body: JSON.stringify({
                spec,
                natural_language: userPrompt || undefined
              }),
            });
            if (!response.ok) throw new Error(await response.text());
            const stream = await response.json();
            addSession(stream.stream_id, stream.ws_url, stream.spec);
            bubble.innerHTML = `
              Stream <code>${escapeHtml(stream.stream_id)}</code> started.
              <div style="margin-top:10px;">
                <a href="#" data-open-stream="${stream.stream_id}" style="color:var(--accent);text-decoration:none;">Open stream workspace →</a>
              </div>
            `;
            const openLink = bubble.querySelector('[data-open-stream]');
            if (openLink) {
              openLink.addEventListener('click', (event) => {
                event.preventDefault();
                loadStream(stream.stream_id);
              });
            }
          } catch (err) {
            bubble.innerHTML = `Failed to launch: ${escapeHtml(err.message)}`;
          }
        });
      }

      if (allowUpdate) {
        const updateBtn = bubble.querySelector('#updateStreamBtn');
        if (updateBtn) {
          updateBtn.addEventListener('click', async () => {
            bubble.innerHTML = `Updating stream <code>${escapeHtml(targetStreamId)}</code>…`;
            try {
              const response = await fetch(`/v1/streams/${targetStreamId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ spec }),
              });
              if (!response.ok) throw new Error(await response.text());
              const stream = await response.json();
              applyStreamResponse(stream);
              bubble.innerHTML = `Stream <code>${escapeHtml(stream.stream_id)}</code> updated.`;
            } catch (err) {
              bubble.innerHTML = `Failed to update: ${escapeHtml(err.message)}`;
            }
          });
        }
      }

      const cancelBtn = bubble.querySelector('#cancelLaunchBtn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          bubble.innerHTML = 'Okay — adjust your request and send again.';
        });
      }
    }

    function cancelPoll(streamId) {
      const timer = pollTimers.get(streamId);
      if (timer) {
        clearTimeout(timer);
        pollTimers.delete(streamId);
      }
    }

    function schedulePoll(streamId) {
      cancelPoll(streamId);
      const timer = setTimeout(() => {
        pollTimers.delete(streamId);
        pollStreamData(streamId);
      }, 10000);
      pollTimers.set(streamId, timer);
    }

    function addSession(streamId, wsUrl, spec) {
      const snapshot = cloneSpec(spec);
      const createdAt = snapshot?.created_at ? new Date(snapshot.created_at).getTime() : Date.now();
      activeStreams.set(streamId, {
        streamId,
        wsUrl,
        spec: snapshot,
        metrics: null,
        schema: null,
        derivedSchema: null,
        status: 'LIVE',
        priceHistory: [],
        latencyHistory: [],
        lastEvent: null,
        socket: null,
        createdAt,
      });
      renderSessions();
      const entry = activeStreams.get(streamId);
      if (entry) {
        openStreamSocket(entry);
      }
      cancelPoll(streamId);
      pollStreamData(streamId);
    }

    function openStreamSocket(entry) {
      try {
        entry.status = 'CONNECTING';
        renderSessions();
        const url = entry.wsUrl.replace('localhost', window.location.hostname);
        const socket = new WebSocket(url);
        entry.socket = socket;

        socket.onopen = () => {
          entry.status = 'LIVE';
          renderSessions();
          if (currentStreamId === entry.streamId) renderStreamDetail(entry);
        };

        socket.onmessage = (event) => {
          try {
            const payload = JSON.parse(event.data);
            entry.lastEvent = payload;
            const tsValue = payload.ts || payload.window_end;
            if (tsValue) {
              const ts = new Date(tsValue).getTime();
              entry.latencyHistory.push(Date.now() - ts);
              if (entry.latencyHistory.length > 50) entry.latencyHistory.shift();
            }

            const price = extractRepresentativePrice(payload);
            if (typeof price === 'number' && !Number.isNaN(price)) {
              entry.priceHistory.push(price);
              if (entry.priceHistory.length > 120) entry.priceHistory.shift();
            }
            if (!entry.schema) {
              entry.derivedSchema = deriveSchemaFromEvent(payload);
            }
            if (currentStreamId === entry.streamId) renderStreamDetail(entry);
            renderSessions();
          } catch (err) {
            console.warn('Malformed event', err);
          }
        };

        socket.onerror = () => {
          entry.status = 'ERROR';
          renderSessions();
        };

        socket.onclose = () => {
          entry.socket = null;
          if (entry.status === 'LIVE') {
            entry.status = 'DISCONNECTED';
          }
          renderSessions();
        };
      } catch (err) {
        console.warn('WebSocket failure', err);
        entry.status = 'ERROR';
        renderSessions();
      }
    }

    function renderSessions() {
      const fragments = [];
      for (const [streamId, stream] of activeStreams.entries()) {
        fragments.push(`
          <div class="session-item ${streamId === currentStreamId ? 'active' : ''}" data-stream="${streamId}">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <strong style="font-size:13px;color:#f7f9ff;">${escapeHtml((stream.spec.symbols || []).join(', ') || streamId.slice(0, 8))}</strong>
              <span>${escapeHtml(stream.status)}</span>
            </div>
            <span>ID: ${escapeHtml(streamId)}</span>
            <span>Interval: ${(stream.spec.interval_sec || 1)}s</span>
          </div>
        `);
      }
      sessionList.innerHTML = fragments.join('') || '<div class="session-empty">No streams launched yet.</div>';
      sessionList.querySelectorAll('[data-stream]').forEach(node => node.addEventListener('click', () => loadStream(node.dataset.stream)));
      renderStreamsDirectory();
    }

    function renderStreamsDirectory() {
      if (!streamsDirectory) return;
      const cards = [];
      for (const [streamId, stream] of activeStreams.entries()) {
        const title = (stream.spec.symbols || []).join(', ') || streamId.slice(0, 8);
        const interval = stream.spec.interval_sec || 1;
        let latencyValue = stream.metrics?.mean_latency_ms;
        const latencyHistory = stream.latencyHistory || [];
        if (latencyValue == null && latencyHistory.length) {
          const sum = latencyHistory.reduce((acc, val) => acc + val, 0);
          latencyValue = sum / latencyHistory.length;
        }
        const latency = latencyValue != null ? `${latencyValue.toFixed(1)} ms` : '—';
        const latestPrice = extractRepresentativePrice(stream.lastEvent);
        const priceText = typeof latestPrice === 'number'
          ? `$${latestPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
          : '—';
        const status = stream.status || 'LIVE';
        const statusClass = status.toUpperCase().includes('STOP')
          ? 'status-pill error'
          : status.toUpperCase().includes('PAUSE')
            ? 'status-pill warn'
            : 'status-pill';
        const eventsPerMinute = stream.metrics?.events_last_minute ?? '—';
        const isActive = streamId === currentStreamId;
        cards.push(`
          <article class="stream-card${isActive ? ' active' : ''}" data-stream="${streamId}">
            <header>
              <h3>${escapeHtml(title)}</h3>
              <span class="${statusClass}">${escapeHtml(status)}</span>
            </header>
            <div class="stream-meta">
              <span>Interval: ${interval}s</span>
              <span>Latency: ${latency}</span>
              <span>Events (60s): ${eventsPerMinute}</span>
              <span>Last price: ${escapeHtml(priceText)}</span>
            </div>
            <footer>
              <span>ID: ${escapeHtml(streamId)}</span>
              <button type="button">Open workspace</button>
            </footer>
          </article>
        `);
      }
      streamsDirectory.innerHTML = cards.join('') || '<div class="stream-empty">No streams launched yet. Use the chat to request one.</div>';
    }

    async function pollStreamData(streamId) {
      if (!activeStreams.has(streamId)) {
        cancelPoll(streamId);
        return;
      }
      try {
        const [schemaRes, metricsRes] = await Promise.all([
          fetch(`/v1/streams/${streamId}/schema`),
          fetch(`/v1/streams/${streamId}/metrics`)
        ]);
        if (!schemaRes.ok) throw new Error(await schemaRes.text());
        if (!metricsRes.ok) throw new Error(await metricsRes.text());
        const schema = await schemaRes.json();
        const metrics = await metricsRes.json();
        const entry = activeStreams.get(streamId);
        if (!entry) return;
        if (schema && Object.keys(schema).length) {
          entry.schema = schema;
        }
        entry.metrics = metrics;
        entry.status = metrics.status || 'LIVE';
        if (metrics.created_at && !Number.isNaN(Date.parse(metrics.created_at))) {
          entry.createdAt = new Date(metrics.created_at).getTime();
        }
        if (metrics.latency_ms != null) {
          entry.latencyHistory.push(metrics.latency_ms);
          if (entry.latencyHistory.length > 20) entry.latencyHistory.shift();
        }
        if (currentStreamId === streamId) renderStreamDetail(entry);
        renderSessions();
      } catch (err) {
        console.warn('Metrics fetch failed', err);
      } finally {
        if (activeStreams.has(streamId)) {
          schedulePoll(streamId);
        } else {
          cancelPoll(streamId);
        }
      }
    }

    function loadStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      currentStreamId = streamId;
      setView(VIEW_DETAIL);
      renderSessions();
      renderStreamDetail(entry);
    }

    function renderStreamDetail(stream) {
      const interval = stream.spec.interval_sec || 1;
      const createdSource = stream.metrics?.created_at || stream.spec.created_at;
      const created = createdSource ? new Date(createdSource) : null;
      let latencyValue = stream.metrics?.mean_latency_ms;
      if (latencyValue == null && stream.latencyHistory.length) {
        const sum = stream.latencyHistory.reduce((acc, val) => acc + val, 0);
        latencyValue = sum / stream.latencyHistory.length;
      }
      const latency = latencyValue != null ? `${latencyValue.toFixed(1)} ms` : '—';
      const latestPrice = extractRepresentativePrice(stream.lastEvent);

      if (headerSummary) {
        headerSummary.innerHTML = `
          <h2>${escapeHtml((stream.spec.symbols || []).join(', ') || stream.streamId)}</h2>
          <div style="display:flex;gap:18px;font-size:13px;color:var(--text-muted);">
            <span>Stream ID: ${escapeHtml(stream.streamId)}</span>
            <span>Interval: ${interval}s</span>
            <span>Latency: ${latency}</span>
            <span>Created: ${created ? created.toISOString() : '—'}</span>
          </div>
        `;
      }

      streamStatus.style.display = 'inline-flex';
      streamStatus.textContent = stream.status;
      streamStatus.className = 'status-pill ' + (stream.status.toUpperCase().includes('STOP') ? 'error' : stream.status.toUpperCase().includes('PAUSE') ? 'warn' : '');

      const schemaToRender = getDisplaySchema(stream);
      const sourceSchemaHtml = renderSourceSchemaBlocks(stream);
      const lastEventJson = stream.lastEvent ? JSON.stringify(stream.lastEvent, null, 2) : null;

      detailBody.innerHTML = `
        <div class="panel">
          <h3>Stream Metadata</h3>
          <dl>
            <dt>Stream ID</dt><dd>${escapeHtml(stream.streamId)}</dd>
            <dt>Status</dt><dd>${escapeHtml(stream.status)}</dd>
            <dt>Interval</dt><dd>${interval}s</dd>
            <dt>Latency</dt><dd>${latency}</dd>
            <dt>Created</dt><dd>${created ? created.toISOString() : '—'}</dd>
            <dt>Symbols</dt><dd>${escapeHtml((stream.spec.symbols || []).join(', '))}</dd>
            <dt>Sources</dt><dd>${escapeHtml((stream.spec.sources || []).map(s => s.type).join(', '))}</dd>
            <dt>Exchanges</dt><dd>${escapeHtml((stream.spec.sources || []).flatMap(s => s.exchange ? [s.exchange.toUpperCase()] : []).join(', ') || 'BINANCEUS')}</dd>
            <dt>Driver Stream</dt><dd>CCXT</dd>
            <dt>Type</dt><dd>AggregatedEvent</dd>
            <dt>Last price</dt><dd>${latestPrice != null ? '$' + latestPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}</dd>
          </dl>
        </div>
        <div class="panel">
          <h3>Data Schema</h3>
          <div style="max-height:220px;overflow:auto;font-family:var(--mono);font-size:12px;border:1px solid rgba(62,120,178,0.2);border-radius:12px;padding:12px;background:rgba(19,23,31,0.95);">
            ${Object.entries(schemaToRender || {}).map(([field, meta]) => {
              if (typeof meta === 'string') {
                return `<div>${escapeHtml(field)}: ${escapeHtml(meta)}</div>`;
              }
              const descriptor = meta?.type ? escapeHtml(meta.type) : 'unknown';
              const suffix = meta?.optional ? ' (optional)' : '';
              return `<div>${escapeHtml(field)}: ${descriptor}${suffix}</div>`;
            }).join('') || 'Schema unavailable'}
          </div>
          <div style="display:flex;gap:10px;">
            <button class="action-btn" onclick="copySchema('${stream.streamId}', 'json')">Copy Schema JSON</button>
            <button class="action-btn" onclick="copySchema('${stream.streamId}', 'csv')">Copy CSV Header</button>
          </div>
        </div>
        ${sourceSchemaHtml ? `
        <div class="panel">
          <h3>Source Schemas</h3>
          ${sourceSchemaHtml}
        </div>` : ''}
        ${lastEventJson ? `
        <div class="panel">
          <h3 style="display:flex;justify-content:space-between;align-items:center;">
            <span>Latest Event</span>
            <button class="action-btn" onclick="copyLatestEvent('${stream.streamId}')">Copy</button>
          </h3>
          <pre style="max-height:220px;overflow:auto;font-family:var(--mono);font-size:12px;border:1px solid rgba(62,120,178,0.2);border-radius:12px;padding:12px;background:rgba(7,10,16,0.95);color:#d9e3f5;" id="latest-event-${stream.streamId}">${escapeHtml(lastEventJson)}</pre>
        </div>` : ''}
        <div class="panel column-merge">
          <h3>Integration Snippets</h3>
          <div class="code-block">
            <button onclick="copySnippet('python-${stream.streamId}')">Copy</button>
            <pre><code id="python-${stream.streamId}"></code></pre>
          </div>
          <div class="code-block">
            <button onclick="copySnippet('ws-${stream.streamId}')">Copy</button>
            <pre><code id="ws-${stream.streamId}"></code></pre>
          </div>
          <div class="code-block">
            <button onclick="copySnippet('curl-${stream.streamId}')">Copy</button>
            <pre><code id="curl-${stream.streamId}"></code></pre>
          </div>
        </div>
        <div class="panel">
          <h3>Actions</h3>
          <div class="actions-list">
            <div class="action-btn" onclick="restartStream('${stream.streamId}')">Restart Stream</div>
            <div class="action-btn" onclick="duplicateStream('${stream.streamId}')">Duplicate Spec</div>
            <div class="action-btn" onclick="downloadSpec('${stream.streamId}')">Download Spec JSON</div>
            <div class="action-btn danger" onclick="stopStream('${stream.streamId}')">Stop Stream</div>
          </div>
        </div>
      `;

      const pythonSnippet = `from ekko import listen\n\nasync def main():\n    async for event in listen("${stream.streamId}"):\n        print(event)`;
      const wsActual = stream.wsUrl.replace('localhost', window.location.hostname);
      const wsDisplay = wsActual.replace(/token=.*$/i, 'token=***');
      const curlSnippet = `curl -X GET "https://api.bond.dev/v1/streams/${stream.streamId}" \\\n     -H "Authorization: Bearer <token>"`;

      setSnippet(`python-${stream.streamId}`, 'python', pythonSnippet);
      setSnippet(`ws-${stream.streamId}`, 'url', wsActual, wsDisplay);
      setSnippet(`curl-${stream.streamId}`, 'shell', curlSnippet);

    }

    function copySchema(streamId, type) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      const schema = getDisplaySchema(entry);
      if (!schema || !Object.keys(schema).length) return;
      if (type === 'json') {
        navigator.clipboard.writeText(JSON.stringify(schema, null, 2));
      } else {
        navigator.clipboard.writeText(Object.keys(schema).join(','));
      }
    }

    function copyLatestEvent(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry?.lastEvent) return;
      navigator.clipboard.writeText(JSON.stringify(entry.lastEvent, null, 2));
    }

    function highlightSnippet(lang, code) {
      let escaped = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      const apply = (regex, cls) => {
        escaped = escaped.replace(regex, `<span class="${cls}">$1</span>`);
      };

      if (lang === 'python') {
        apply(/\b(async|await|for|in|from|import|print|return|def|class|with|as|yield|if|else|elif)\b/g, 'kw');
        apply(/\b(True|False|None)\b/g, 'const');
        apply(/(&quot;.*?&quot;)/g, 'str');
        apply(/(&#39;.*?&#39;)/g, 'str');
        apply(/(#.*?$)/gm, 'comment');
      } else if (lang === 'shell') {
        apply(/^(curl)/gm, 'cmd');
        apply(/\s(-{1,2}\w+)/g, 'flag');
        apply(/(https?:\/\/[^\s]+)/g, 'str');
        apply(/(".*?")/g, 'str');
      } else if (lang === 'url') {
        apply(/(wss?:\/\/[^\s]+)/g, 'str');
        apply(/(token=)([^\s]+)/g, 'flag');
      }

      escaped = escaped
        .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
        .replace(/  /g, '&nbsp;&nbsp;')
        .replace(/\n/g, '<br>');

      return escaped;
    }

    function setSnippet(elementId, lang, code, displayCode = null) {
      const node = document.getElementById(elementId);
      if (!node) return;
      node.dataset.snippet = code;
      const toRender = displayCode == null ? code : displayCode;
      node.innerHTML = highlightSnippet(lang, toRender);
    }

    function copySnippet(elementId) {
      const node = document.getElementById(elementId);
      if (!node) return;
      const text = node.dataset.snippet || node.innerText || '';
      navigator.clipboard.writeText(text);
    }

    function extractRepresentativePrice(event) {
      if (!event) return null;
      if (typeof event.price_close === 'number') return event.price_close;
      if (typeof event.price_avg === 'number') return event.price_avg;
      const exchangeData = event.raw_data?.exchange_data;
      if (exchangeData) {
        for (const exchange of Object.keys(exchangeData)) {
          const symbols = exchangeData[exchange]?.symbols || {};
          for (const symbol of Object.keys(symbols)) {
            const price = symbols[symbol]?.price;
            if (typeof price === 'number') return price;
          }
        }
      }
      return null;
    }

    const MARKET_ONLY_FIELDS = new Set([
      'price_avg', 'price_high', 'price_low', 'price_open', 'price_close',
      'bid_avg', 'ask_avg', 'bid_volume', 'ask_volume',
      'volume_sum', 'volume_base_sum',
      'onchain_count', 'onchain_value_sum',
      'custom_count'
    ]);

    const SOURCE_SCHEMA_DEFS = {
      ccxt: [
        { name: 'ts', type: 'timestamp', description: 'Event timestamp (UTC)' },
        { name: 'window_start', type: 'timestamp', description: 'Window start for aggregation' },
        { name: 'window_end', type: 'timestamp', description: 'Window end for aggregation' },
        { name: 'price_open', type: 'float', description: 'First trade price in window' },
        { name: 'price_high', type: 'float', description: 'Highest trade price in window' },
        { name: 'price_low', type: 'float', description: 'Lowest trade price in window' },
        { name: 'price_close', type: 'float', description: 'Last trade price in window' },
        { name: 'price_avg', type: 'float', description: 'VWAP for the window' },
        { name: 'volume_sum', type: 'float', description: 'Total traded quote volume' },
      ],
      nitter: [
        { name: 'ts', type: 'timestamp', description: 'Ingestion timestamp' },
        { name: 'tweets', type: 'int', description: 'Tweets observed in window' },
        { name: 'raw_data.tweet_data.text', type: 'string', description: 'Tweet text' },
        { name: 'raw_data.tweet_data.timestamp_posted', type: 'string', description: 'Original tweet timestamp' },
        { name: 'raw_data.tweet_data.stats', type: 'string', description: 'Like/retweet/reply stats' },
        { name: 'raw_data.tweet_data.symbol', type: 'string', description: 'Handle or symbol extracted' },
        { name: 'raw_data.tweet_data.event_type', type: 'string', description: 'Event type, e.g. tweet' },
        { name: 'raw_data.tweet_data.tweet_type', type: 'string', description: 'tweet | retweet | quote' }
      ],
      google_trends: [
        { name: 'ts', type: 'timestamp', description: 'Collection timestamp' },
        { name: 'raw_data.keyword', type: 'string', description: 'Keyword tracked' },
        { name: 'raw_data.score', type: 'int', description: 'Relative interest score' },
        { name: 'raw_data.geo', type: 'string', description: 'Region (if specified)' }
      ],
      polymarket: [
        { name: 'ts', type: 'timestamp', description: 'Ingestion timestamp' },
        { name: 'event_id', type: 'string', description: 'Polymarket event identifier' },
        { name: 'title', type: 'string', description: 'Event title' },
        { name: 'category', type: 'string', description: 'Event category' },
        { name: 'open_interest', type: 'float', description: 'Open interest (USD)' },
        { name: 'liquidity', type: 'float', description: 'Available liquidity (USD)' },
        { name: 'volume_total', type: 'float', description: 'Lifetime volume (USD)' },
        { name: 'volume_24h', type: 'float', description: '24h volume (USD)' },
        { name: 'market_count', type: 'int', description: 'Number of markets within the event' }
      ]
    };

    function deriveSchemaFromEvent(event) {
      if (!event || typeof event !== 'object') return null;
      const result = {};
      for (const [key, value] of Object.entries(event)) {
        result[key] = inferType(value);
      }
      return result;
    }

    function normalizeSchemaDict(schema) {
      if (!schema) return null;
      if (Array.isArray(schema)) {
        const map = {};
        for (const field of schema) {
          if (!field || typeof field !== 'object' || !field.name) continue;
          const meta = {};
          if (field.type) meta.type = field.type;
          if (field.optional != null) meta.optional = Boolean(field.optional);
          if (field.description) meta.description = field.description;
          map[field.name] = Object.keys(meta).length ? meta : 'any';
        }
        return Object.keys(map).length ? map : null;
      }
      if (schema.fields && Array.isArray(schema.fields)) {
        return normalizeSchemaDict(schema.fields);
      }
      if (typeof schema === 'object') {
        const map = {};
        for (const [key, value] of Object.entries(schema)) {
          if (key === 'stream_id') continue;
          if (key === 'fields' && Array.isArray(value)) {
            const nested = normalizeSchemaDict(value);
            if (nested) Object.assign(map, nested);
            continue;
          }
          map[key] = value;
        }
        return Object.keys(map).length ? map : null;
      }
      return null;
    }

    function collectSourceSchemaUnion(stream) {
      const union = {};
      if (!stream?.spec?.sources) return union;
      for (const source of stream.spec.sources) {
        const defs = SOURCE_SCHEMA_DEFS[source.type];
        if (!defs) continue;
        for (const field of defs) {
          union[field.name] = {
            type: field.type,
            optional: field.optional ?? false,
            description: field.description,
          };
        }
      }
      return union;
    }

    function inferType(value) {
      if (value === null || value === undefined) return { type: 'unknown', optional: true };
      if (typeof value === 'number') {
        return { type: Number.isInteger(value) ? 'int' : 'float' };
      }
      if (typeof value === 'string') return { type: 'string' };
      if (typeof value === 'boolean') return { type: 'bool' };
      if (Array.isArray(value)) return { type: 'array' };
      if (value instanceof Date) return { type: 'datetime' };
      if (typeof value === 'object') {
        return { type: 'object', optional: false };
      }
      return { type: typeof value };
    }

    function describeSourceTitle(source, stream) {
      if (!source) return 'Source';
      if (source.type === 'ccxt') {
        const exchange = (source.exchange || 'binanceus').toUpperCase();
        const symbols = (source.symbols && source.symbols.length ? source.symbols : stream.spec?.symbols || []).join(', ');
        return `CCXT · ${exchange}${symbols ? ` · ${symbols}` : ''}`;
      }
      if (source.type === 'nitter') {
        return `Nitter · @${source.username || 'elonmusk'}`;
      }
      if (source.type === 'google_trends') {
        const keywords = (source.keywords || []).join(', ');
        return keywords ? `Google Trends · ${keywords}` : 'Google Trends';
      }
      if (source.type === 'polymarket') {
        const events = (source.event_ids || []).join(', ');
        const categories = (source.categories || []).join(', ');
        if (events) return `Polymarket · ${events}`;
        if (categories) return `Polymarket · ${categories}`;
        return 'Polymarket · Events';
      }
      return source.type.toUpperCase();
    }

    function renderSourceSchemaBlocks(stream) {
      const sources = stream.spec?.sources || [];
      const blocks = [];
      for (const source of sources) {
        const defs = SOURCE_SCHEMA_DEFS[source.type];
        if (!defs || !defs.length) continue;
        const rows = defs.map(field => `
          <div class="source-schema-field">
            <span>${escapeHtml(field.name)}</span>
            <span>${escapeHtml(field.type)}${field.description ? ` · ${escapeHtml(field.description)}` : ''}</span>
          </div>
        `).join('');
        blocks.push(`
          <div class="source-schema-block">
            <div class="source-schema-title">${escapeHtml(describeSourceTitle(source, stream))}</div>
            <div class="source-schema-grid">
              ${rows}
            </div>
          </div>
        `);
      }
      return blocks.join('');
    }

    function getDisplaySchema(stream) {
      const normalized = normalizeSchemaDict(stream.schema);
      const base = normalized && Object.keys(normalized).length ? normalized : {};
      const derived = stream.derivedSchema || {};
      const combined = { ...base, ...derived };
      const entries = Object.entries(combined);
      const filtered = {};
      const eventKeys = stream.lastEvent ? new Set(Object.keys(stream.lastEvent)) : null;
      const hasCcxtSource = (stream.spec?.sources || []).some(src => src.type === 'ccxt');

      for (const [field, meta] of entries) {
        if (eventKeys && !eventKeys.has(field)) continue;
        filtered[field] = meta;
      }

      let candidate;
      if (Object.keys(filtered).length) {
        candidate = filtered;
      } else if (Object.keys(derived).length) {
        candidate = { ...derived };
      } else {
        candidate = { ...combined };
      }

      if (!hasCcxtSource) {
        for (const field of Object.keys(candidate)) {
          if (MARKET_ONLY_FIELDS.has(field)) {
            delete candidate[field];
          }
        }
      }

      if (!Object.keys(candidate).length) {
        const union = collectSourceSchemaUnion(stream);
        if (Object.keys(union).length) {
          Object.assign(candidate, union);
        }
      }

      if ((!candidate.symbol) && ((stream.spec?.symbols || []).length > 1 || stream.lastEvent?.symbol)) {
        candidate.symbol = { type: 'string' };
      }

      return Object.keys(candidate).length ? candidate : null;
    }

    function formatDuration(milliseconds) {
      if (!Number.isFinite(milliseconds) || milliseconds < 0) return null;
      const totalSeconds = Math.floor(milliseconds / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const parts = [];
      if (hours) parts.push(`${hours}h`);
      if (minutes) parts.push(`${minutes}m`);
      if (!parts.length || seconds) parts.push(`${seconds}s`);
      return parts.join(' ');
    }

    async function refreshMetrics(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch(`/v1/streams/${streamId}/metrics`);
        if (!response.ok) throw new Error(await response.text());
        entry.metrics = await response.json();
        renderStreamDetail(entry);
      } catch (err) {
        appendMessage('agent', `Unable to refresh metrics: ${escapeHtml(err.message)}`);
      }
    }

    async function restartStream(streamId) {
      try {
        const response = await fetch(`/v1/streams/${streamId}/restart`, { method: 'PATCH' });
        if (!response.ok) throw new Error(await response.text());
        const stream = await response.json();
        applyStreamResponse(stream);
        appendMessage('agent', `Stream ${escapeHtml(streamId)} restarted.`);
      } catch (err) {
        appendMessage('agent', `Restart failed: ${escapeHtml(err.message)}`);
      }
    }

    async function duplicateStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch('/v1/streams', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ spec: cloneSpec(entry.spec) }),
        });
        if (!response.ok) throw new Error(await response.text());
        const stream = await response.json();
        appendMessage('agent', `Duplicated stream as <code>${escapeHtml(stream.stream_id)}</code>.`);
        addSession(stream.stream_id, stream.ws_url, stream.spec);
        loadStream(stream.stream_id);
      } catch (err) {
        appendMessage('agent', `Duplicate failed: ${escapeHtml(err.message)}`);
      }
    }

    async function downloadSpec(streamId) {
      try {
        const response = await fetch(`/v1/streams/${streamId}/spec`);
        if (!response.ok) throw new Error(await response.text());
        const spec = await response.json();
        const blob = new Blob([JSON.stringify(spec, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${streamId}_spec.json`;
        link.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        appendMessage('agent', `Spec download failed: ${escapeHtml(err.message)}`);
      }
    }

    async function stopStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch(`/v1/streams/${streamId}`, { method: 'DELETE' });
        if (!response.ok) throw new Error(await response.text());
        appendMessage('agent', `Stream ${escapeHtml(streamId)} stopped.`);
        if (entry.socket) {
          entry.socket.close();
          entry.socket = null;
        }
        const removedWasCurrent = streamId === currentStreamId;
        activeStreams.delete(streamId);
        cancelPoll(streamId);
        if (removedWasCurrent) {
          currentStreamId = null;
          detailBody.innerHTML = '<div class="panel column-merge" style="text-align:center;opacity:0.6;"><h3>Stream stopped</h3><p style="font-size:13px;color:var(--text-muted);">Select another stream or launch a new one.</p></div>';
          streamStatus.style.display = 'none';
        }
        renderSessions();
        if (removedWasCurrent) {
          setView(activeStreams.size ? VIEW_STREAMS : VIEW_CHAT);
        }
      } catch (err) {
        appendMessage('agent', `Failed to stop stream: ${escapeHtml(err.message)}`);
      }
    }

    document.addEventListener('keydown', (event) => {
      if (event.metaKey && event.key.toLowerCase() === 'n') {
        event.preventDefault();
        messageInput.focus();
      }
      if (event.metaKey && event.key.toLowerCase() === 'k') {
        event.preventDefault();
        pauseAll = !pauseAll;
        appendMessage('agent', pauseAll ? 'All streams paused (not yet implemented).' : 'Resume streams (not yet implemented).');
        setPauseButtonLabels();
      }
    });

    renderSessions();
    setView(VIEW_CHAT);

    appendMessage('agent', `Echo Agent ready.
    <div style="margin-top:12px;font-size:12px;color:var(--text-muted);">
      Try: "Stream BTC/USDT every 5 seconds."
      <br/>Move over to Streams whenever you want to inspect or tweak an active feed.
    </div>`);
  </script>

  <!-- Supabase Auth -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = 'https://eezdrsmjpycrzuriyzni.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVlemRyc21qcHljcnp1cml5em5pIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1MDQ1NTgsImV4cCI6MjA3ODA4MDU1OH0.kBl6L1pnX1OnNbTYURcNfijIK8Oqq4xfjXECwLLm_4o';

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const authStatus = document.getElementById('auth-status');
    const loginLink = document.getElementById('login-link');
    const userEmailDisplay = document.getElementById('user-email-display');
    const userDropdown = document.getElementById('user-dropdown');
    const tierBadge = document.getElementById('tier-badge');
    const streamsCount = document.getElementById('streams-count');
    const monthlyCount = document.getElementById('monthly-count');
    const logoutBtn = document.getElementById('logout-btn');

    // Toggle dropdown on click
    if (userEmailDisplay) {
      userEmailDisplay.addEventListener('click', (e) => {
        e.stopPropagation();
        userDropdown.style.display = userDropdown.style.display === 'none' ? 'block' : 'none';
      });
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (userDropdown && !authStatus.contains(e.target)) {
        userDropdown.style.display = 'none';
      }
    });

    // Check auth status on page load
    async function checkAuthStatus() {
      const { data: { session } } = await supabase.auth.getSession();

      if (session) {
        // User is logged in
        userEmailDisplay.textContent = session.user.email;
        authStatus.style.display = 'block';
        loginLink.style.display = 'none';

        // Fetch user stats
        await fetchUserStats(session.access_token);
      } else {
        // User is not logged in
        authStatus.style.display = 'none';
        loginLink.style.display = 'inline-flex';
      }
    }

    // Fetch user stats from API
    async function fetchUserStats(token) {
      try {
        const response = await fetch('/v1/user/stats', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const stats = await response.json();

          // Update tier badge
          tierBadge.textContent = stats.tier.toUpperCase();
          tierBadge.style.background = stats.tier === 'free' ? 'rgba(59,130,246,0.15)' :
                                       stats.tier === 'pro' ? 'rgba(168,85,247,0.15)' :
                                       'rgba(234,179,8,0.15)';
          tierBadge.style.color = stats.tier === 'free' ? '#60a5fa' :
                                  stats.tier === 'pro' ? '#c084fc' :
                                  '#facc15';

          // Update counts (simplified format for dropdown)
          streamsCount.textContent = `${stats.active_streams}/${stats.tier_limit}`;
          monthlyCount.textContent = `${stats.monthly_streams}`;

          // Warning if over limit
          if (stats.active_streams >= stats.tier_limit) {
            streamsCount.style.color = '#f87171';
          } else {
            streamsCount.style.color = 'var(--text)';
          }
        }
      } catch (e) {
        console.error('Error fetching user stats:', e);
      }
    }

    // Load history from API
    async function loadHistory() {
      const { data: { session } } = await supabase.auth.getSession();

      if (!session) {
        document.getElementById('historyList').innerHTML = '<p style="text-align: center; color: var(--text-muted);">Please sign in to view your stream history.</p>';
        return;
      }

      try {
        const response = await fetch('/v1/user/history', {
          headers: {
            'Authorization': `Bearer ${session.access_token}`
          }
        });

        if (response.ok) {
          const data = await response.json();
          renderHistory(data.history);
        } else {
          document.getElementById('historyList').innerHTML = '<p style="text-align: center; color: var(--text-muted);">Error loading history.</p>';
        }
      } catch (e) {
        console.error('Error loading history:', e);
        document.getElementById('historyList').innerHTML = '<p style="text-align: center; color: var(--text-muted);">Error loading history.</p>';
      }
    }

    // Render history items
    function renderHistory(history) {
      const historyList = document.getElementById('historyList');

      if (!history || history.length === 0) {
        historyList.innerHTML = '<p style="text-align: center; color: var(--text-muted);">No streams created yet.</p>';
        return;
      }

      historyList.innerHTML = history.map(item => {
        const createdDate = new Date(item.created_at);
        const statusColor = item.is_active ? '#16a34a' : '#8aa1c5';
        const statusText = item.is_active ? 'LIVE' : 'STOPPED';

        return `
          <div style="background: rgba(14, 22, 39, 0.6); border: 1px solid rgba(59,130,246,0.15); border-radius: 12px; padding: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
              <div style="flex: 1;">
                <div style="font-size: 14px; color: var(--text); margin-bottom: 6px;">${escapeHtml(item.user_query)}</div>
                <div style="font-size: 12px; color: var(--text-muted); font-family: var(--mono);">
                  Stream ID: ${escapeHtml(item.stream_id)}
                </div>
                <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                  ${createdDate.toLocaleString()}
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="color: ${statusColor}; font-size: 11px; font-weight: 600;">• ${statusText}</span>
                ${item.is_active ? `<button class="stop-stream-btn" data-stream-id="${escapeHtml(item.stream_id)}" style="border: 1px solid rgba(248,113,113,0.35); background: rgba(248,113,113,0.12); color: #fca5a5; font-size: 11px; padding: 4px 10px; border-radius: 6px; cursor: pointer; transition: all 0.2s;">Stop</button>` : ''}
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Add event listeners to stop buttons
      document.querySelectorAll('.stop-stream-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const streamId = e.target.getAttribute('data-stream-id');
          if (!streamId) return;

          e.target.disabled = true;
          e.target.textContent = 'Stopping...';

          try {
            const response = await fetch(`/v1/streams/${streamId}`, {
              method: 'DELETE'
            });

            if (response.ok) {
              // Reload history to reflect changes
              await loadHistory();
            } else {
              alert('Failed to stop stream');
              e.target.disabled = false;
              e.target.textContent = 'Stop';
            }
          } catch (error) {
            console.error('Error stopping stream:', error);
            alert('Error stopping stream');
            e.target.disabled = false;
            e.target.textContent = 'Stop';
          }
        });
      });
    }

    // Handle logout
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async () => {
        await supabase.auth.signOut();
        window.location.href = '/login';
      });
    }

    // Initialize auth status
    checkAuthStatus();

    // Listen for auth changes
    supabase.auth.onAuthStateChange((event, session) => {
      checkAuthStatus();
    });
  </script>
</body>
</html>

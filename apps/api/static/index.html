<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bond Terminal · Stream Console</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #060b16;
      --panel: #0e1627;
      --panel-strong: #111c33;
      --border: #1f2f4a;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.18);
      --success: #16a34a;
      --warn: #d97706;
      --error: #dc2626;
      --text: #e6ecff;
      --text-muted: #8aa1c5;
      --mono: 'JetBrains Mono', monospace;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      height: 62px;
      border-bottom: 1px solid rgba(31, 47, 74, 0.85);
      background: #0b1323;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 28px;
    }

    header .brand {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    header .brand h1 {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    header nav {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    header button,
    header a {
      border: 1px solid rgba(59, 130, 246, 0.28);
      background: rgba(13, 21, 36, 0.85);
      color: var(--text);
      font-size: 13px;
      padding: 8px 14px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      text-decoration: none;
      transition: transform 0.15s ease, background 0.15s ease;
    }

    header button.primary {
      background: linear-gradient(135deg, rgba(59,130,246,0.9), rgba(37,99,235,0.85));
      border-color: rgba(59,130,246,0.55);
      box-shadow: 0 10px 24px rgba(59,130,246,0.25);
    }

    header button:hover,
    header a:hover {
      transform: translateY(-1px);
      background: rgba(27, 39, 58, 0.95);
    }

    header button.primary:hover {
      transform: translateY(-2px);
    }

    main {
      flex: 1;
      display: flex;
      min-height: 0;
    }

    .left-pane {
      width: 360px;
      border-right: 1px solid rgba(31, 47, 74, 0.8);
      background: rgba(10, 17, 30, 0.92);
      display: flex;
      flex-direction: column;
    }

    .session-list {
      padding: 18px 16px;
      border-bottom: 1px solid rgba(31,47,74,0.7);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-list h2 {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .sessions {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .session-item {
      padding: 14px;
      border-radius: 12px;
      border: 1px solid rgba(59, 130, 246, 0.22);
      background: rgba(59, 130, 246, 0.08);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.15s ease, border 0.15s ease;
    }

    .session-item.active,
    .session-item:hover {
      transform: translateY(-2px);
      border-color: rgba(59,130,246,0.4);
      background: rgba(59, 130, 246, 0.12);
    }

    .session-item span {
      font-size: 12px;
      color: var(--text-muted);
    }

    .chat-log {
      height: 260px;
      overflow-y: auto;
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      border-top: 1px solid rgba(31, 47, 74, 0.6);
      border-bottom: 1px solid rgba(31, 47, 74, 0.6);
    }

    .chat-msg {
      display: flex;
      gap: 8px;
      font-size: 13px;
      animation: fadeIn 0.12s ease-out;
    }

    .chat-msg.agent { flex-direction: row; }
    .chat-msg.user { flex-direction: row-reverse; }

    .avatar {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      display: grid;
      place-items: center;
      background: rgba(59, 130, 246, 0.18);
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing: 0.06em;
      color: var(--accent);
    }

    .chat-msg.agent .avatar {
      background: rgba(59, 130, 246, 0.35);
      color: #f8fbff;
    }

    .bubble {
      max-width: 80%;
      background: rgba(15, 24, 39, 0.92);
      border: 1px solid rgba(59, 130, 246, 0.18);
      border-radius: 10px;
      padding: 10px 12px;
      line-height: 1.5;
    }

    .chat-msg.user .bubble {
      background: rgba(59, 130, 246, 0.12);
      border-color: rgba(59, 130, 246, 0.25);
      color: #dbeafe;
    }

    .chat-input {
      border-bottom: 1px solid rgba(31,47,74,0.6);
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .chat-input textarea {
      height: 110px;
      resize: none;
      border-radius: 10px;
      background: rgba(9, 15, 27, 0.9);
      border: 1px solid rgba(45, 64, 96, 0.8);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.55;
    }

    .chat-input textarea:focus {
      outline: none;
      border-color: rgba(59,130,246,0.5);
      box-shadow: 0 0 0 1px rgba(59,130,246,0.15);
      background: rgba(13,22,37,0.95);
    }

    .chat-input button {
      align-self: flex-end;
      border-radius: 10px;
      border: 1px solid rgba(59,130,246,0.35);
      background: rgba(59,130,246,0.16);
      color: #dbeafe;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
    }

    .detail-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .detail-header {
      padding: 20px 30px;
      border-bottom: 1px solid rgba(31, 47, 74, 0.75);
      background: rgba(12, 18, 31, 0.98);
      display: flex;
      justify-content: space-between;
      gap: 40px;
    }

    .detail-header .summary {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .summary h2 {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: -0.015em;
    }

    .summary meta-row {
      display: flex;
      gap: 16px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-family: var(--mono);
      font-size: 12px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(16, 185, 129, 0.35);
      background: rgba(16, 185, 129, 0.18);
      color: #bef5d2;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .detail-body {
      padding: 24px 26px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 20px;
      align-items: start;
      overflow-y: auto;
      max-height: calc(100vh - 62px - 80px);
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 22px 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      box-shadow: 0 14px 34px rgba(6, 12, 24, 0.45);
    }

    .panel h3 {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: #c5d8ff;
    }

    .panel dl {
      display: grid;
      grid-template-columns: minmax(120px, 0.4fr) 1fr;
      row-gap: 10px;
      column-gap: 12px;
      font-size: 13px;
    }

    .panel dt {
      color: var(--text-muted);
      font-family: var(--mono);
      letter-spacing: 0.02em;
    }

    .panel dd {
      font-family: var(--mono);
      color: #dce7ff;
    }

    .code-block {
      background: #080f1f;
      border: 1px solid rgba(59,130,246,0.22);
      border-radius: 12px;
      padding: 12px 0 0 0;
      position: relative;
      overflow: hidden;
    }

    .code-block button {
      position: absolute;
      top: 10px;
      right: 10px;
      border: 1px solid rgba(59,130,246,0.35);
      background: rgba(59,130,246,0.15);
      color: #dbeafe;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 11px;
      cursor: pointer;
    }

    .code-block pre {
      margin: 0;
      padding: 18px 18px 16px;
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.6;
      color: #cbd9ff;
    }

    .code-block .kw { color: #93c5fd; }
    .code-block .const { color: #f9a8d4; }
    .code-block .str { color: #bef264; }
    .code-block .cmd { color: #facc15; }
    .code-block .flag { color: #fca5a5; }
    .code-block .comment { color: #94a3b8; }

    .actions-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .action-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid rgba(59,130,246,0.25);
      background: rgba(18,28,45,0.9);
      padding: 12px 14px;
      border-radius: 12px;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.15s ease;
    }

    .action-btn:hover {
      background:rgba(27,39,59,0.95);
      transform: translateY(-1px);
    }

    .action-btn.danger {
      border-color: rgba(239, 68, 68, 0.45);
      background: rgba(127, 29, 29, 0.25);
      color: #fca5a5;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px 18px;
      font-family: var(--mono);
      font-size: 13px;
    }

    .metrics-grid div span {
      display: block;
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: 0.03em;
      margin-bottom: 4px;
    }

    .sparkline-container {
      height: 50px;
      background: rgba(59, 130, 246, 0.08);
      border: 1px solid rgba(59,130,246,0.15);
      border-radius: 12px;
      padding: 4px 6px;
    }

    .sparkline-container canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .column-merge {
      grid-column: 1 / -1;
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div>
        <h1>Bond Stream Console</h1>
        <span style="font-size:13px;color:var(--text-muted);">Developer-first live data governance</span>
      </div>
    </div>
    <nav>
      <button class="primary" id="toolbarNew">New Stream</button>
      <button id="toolbarPause">Pause All</button>
      <button id="toolbarExport">Export Data</button>
      <a href="https://docs.example.com" target="_blank" rel="noreferrer">Docs</a>
      <button id="toolbarSettings">Settings</button>
    </nav>
  </header>

  <main>
    <aside class="left-pane">
      <div class="session-list">
        <h2>Sessions</h2>
        <button id="sessionNewBtn" style="border:none;background:rgba(59,130,246,0.16);padding:6px 10px;border-radius:8px;color:var(--accent);font-size:12px;cursor:pointer;">New</button>
      </div>
      <div class="sessions" id="sessionList"></div>
      <div class="chat-log" id="chatLog"></div>
      <form class="chat-input" id="chatForm">
        <textarea id="messageInput" placeholder="Ask Bond Agent to create or modify streams…" rows="4"></textarea>
        <button type="submit">Submit</button>
      </form>
    </aside>

    <section class="detail-pane" id="detailPane">
      <div class="detail-header" id="streamHeader">
        <div class="summary">
          <h2>Select a stream to view details</h2>
          <div style="display:flex;gap:18px;font-size:13px;color:var(--text-muted);">
            <span>No stream loaded</span>
          </div>
        </div>
        <span class="status-pill" id="streamStatus" style="display:none;">• LIVE</span>
      </div>
      <div class="detail-body" id="detailBody">
        <div class="panel column-merge" style="text-align:center;opacity:0.6;">
          <h3 style="margin-bottom:10px;">Awaiting Selection</h3>
          <p style="font-size:13px;color:var(--text-muted);">
            Use Bond Agent to launch a stream or select one from the Sessions list to inspect its metadata, schema, integrations, and performance metrics.
          </p>
        </div>
      </div>
    </section>
  </main>

  <script>
    const chatLog = document.getElementById('chatLog');
    const chatForm = document.getElementById('chatForm');
    const messageInput = document.getElementById('messageInput');
    const sessionList = document.getElementById('sessionList');
    const detailHeader = document.getElementById('streamHeader');
    const headerSummary = detailHeader.querySelector('.summary');
    const detailBody = document.getElementById('detailBody');
    const streamStatus = document.getElementById('streamStatus');

    const activeStreams = new Map();
    let currentStreamId = null;
    let pauseAll = false;

    function escapeHtml(str = '') {
      return str.replace(/[&<>"]+/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]));
    }

    function appendMessage(role, html) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chat-msg ' + role;
      wrapper.innerHTML = `
        <div class="avatar">${role === 'agent' ? 'AI' : 'ME'}</div>
        <div class="bubble">${html}</div>
      `;
      chatLog.appendChild(wrapper);
      chatLog.scrollTop = chatLog.scrollHeight;
      return wrapper.querySelector('.bubble');
    }

    chatForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      const prompt = messageInput.value.trim();
      if (!prompt) return;

      appendMessage('user', escapeHtml(prompt));
      messageInput.value = '';

      const pending = appendMessage('agent', `Parsing “${escapeHtml(prompt)}”…`);
      try {
        const response = await fetch('/v1/streams/parse', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query: prompt }),
        });
        if (!response.ok) throw new Error(await response.text());
        const parsed = await response.json();
        renderParseSummary(parsed, pending);
      } catch (err) {
        pending.innerHTML = `
          <div>Error parsing request.</div>
          <div style="margin-top:8px;color:#fca5a5;font-size:13px;">${escapeHtml(err.message)}</div>
        `;
      }
    });

    function renderParseSummary(parsed, bubble) {
      const rows = parsed.spec.sources.filter(src => src.type === 'ccxt').map(src => `
        <tr>
          <td>${escapeHtml((src.exchange || 'BINANCEUS').toUpperCase())}</td>
          <td>${escapeHtml((src.symbols || []).join(', '))}</td>
          <td>${escapeHtml((src.fields || []).join(', ') || 'price, volume')}</td>
        </tr>
      `).join('');

      bubble.innerHTML = `
        <div>Here’s the stream I can create:</div>
        <table style="margin-top:12px;border-collapse:collapse;width:100%;font-size:12px;">
          <thead>
            <tr style="background:rgba(59,130,246,0.18);">
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(59,130,246,0.15);">Exchange</th>
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(59,130,246,0.15);">Symbols</th>
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(59,130,246,0.15);">Fields</th>
            </tr>
          </thead>
          <tbody>${rows || '<tr><td colspan="3" style="padding:8px;color:#f87171;">No CCXT source detected.</td></tr>'}</tbody>
        </table>
        <div style="margin-top:12px;display:flex;gap:10px;">
          <button id="confirmLaunchBtn" style="border:1px solid rgba(59,130,246,0.35);background:rgba(59,130,246,0.15);color:#dbeafe;padding:8px 12px;border-radius:10px;font-size:12px;cursor:pointer;">Launch</button>
          <button id="cancelLaunchBtn" style="border:1px solid rgba(148,163,184,0.35);background:rgba(148,163,184,0.12);color:#cbd5f5;padding:8px 12px;border-radius:10px;font-size:12px;cursor:pointer;">Modify</button>
        </div>
      `;

      bubble.querySelector('#confirmLaunchBtn').addEventListener('click', async () => {
        bubble.innerHTML = 'Launching stream…';
        try {
          const response = await fetch('/v1/streams', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ spec: parsed.spec }),
          });
          if (!response.ok) throw new Error(await response.text());
          const stream = await response.json();
          bubble.innerHTML = `Stream <code>${escapeHtml(stream.stream_id)}</code> started.`;
          addSession(stream.stream_id, stream.ws_url, parsed.spec);
          loadStream(stream.stream_id);
        } catch (err) {
          bubble.innerHTML = `Failed to launch: ${escapeHtml(err.message)}`;
        }
      });

      bubble.querySelector('#cancelLaunchBtn').addEventListener('click', () => {
        bubble.innerHTML = 'Okay — adjust your request and send again.';
      });
    }

    function addSession(streamId, wsUrl, spec) {
      activeStreams.set(streamId, {
        streamId,
        wsUrl,
        spec,
        metrics: null,
        schema: null,
        derivedSchema: null,
        status: 'LIVE',
        priceHistory: [],
        latencyHistory: [],
        lastEvent: null,
        socket: null,
        createdAt: spec?.created_at ? new Date(spec.created_at).getTime() : Date.now(),
      });
      renderSessions();
      const entry = activeStreams.get(streamId);
      if (entry) {
        openStreamSocket(entry);
      }
      pollStreamData(streamId);
    }

    function openStreamSocket(entry) {
      try {
        entry.status = 'CONNECTING';
        renderSessions();
        const url = entry.wsUrl.replace('localhost', window.location.hostname);
        const socket = new WebSocket(url);
        entry.socket = socket;

        socket.onopen = () => {
          entry.status = 'LIVE';
          renderSessions();
          if (currentStreamId === entry.streamId) renderStreamDetail(entry);
        };

        socket.onmessage = (event) => {
          try {
            const payload = JSON.parse(event.data);
            entry.lastEvent = payload;
            const tsValue = payload.ts || payload.window_end;
            if (tsValue) {
              const ts = new Date(tsValue).getTime();
              entry.latencyHistory.push(Date.now() - ts);
              if (entry.latencyHistory.length > 50) entry.latencyHistory.shift();
            }

            const price = extractRepresentativePrice(payload);
            if (typeof price === 'number' && !Number.isNaN(price)) {
              entry.priceHistory.push(price);
              if (entry.priceHistory.length > 120) entry.priceHistory.shift();
            }
            if (!entry.schema) {
              entry.derivedSchema = deriveSchemaFromEvent(payload);
            }
            if (currentStreamId === entry.streamId) renderStreamDetail(entry);
            renderSessions();
          } catch (err) {
            console.warn('Malformed event', err);
          }
        };

        socket.onerror = () => {
          entry.status = 'ERROR';
          renderSessions();
        };

        socket.onclose = () => {
          entry.socket = null;
          if (entry.status === 'LIVE') {
            entry.status = 'DISCONNECTED';
          }
          renderSessions();
        };
      } catch (err) {
        console.warn('WebSocket failure', err);
        entry.status = 'ERROR';
        renderSessions();
      }
    }

    function renderSessions() {
      const fragments = [];
      for (const [streamId, stream] of activeStreams.entries()) {
        fragments.push(`
          <div class="session-item ${streamId === currentStreamId ? 'active' : ''}" data-stream="${streamId}">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <strong style="font-size:13px;">${escapeHtml((stream.spec.symbols || []).join(', ') || streamId.slice(0, 8))}</strong>
              <span>${stream.status}</span>
            </div>
            <span>ID: ${escapeHtml(streamId)}</span>
            <span>Interval: ${(stream.spec.interval_sec || 1)}s</span>
          </div>
        `);
      }
      sessionList.innerHTML = fragments.join('') || '<div style="color:var(--text-muted);font-size:12px;">No streams launched yet.</div>';
      sessionList.querySelectorAll('[data-stream]').forEach(node => node.addEventListener('click', () => loadStream(node.dataset.stream)));
    }

    async function pollStreamData(streamId) {
      try {
        const [schemaRes, metricsRes] = await Promise.all([
          fetch(`/v1/streams/${streamId}/schema`),
          fetch(`/v1/streams/${streamId}/metrics`)
        ]);
        if (!schemaRes.ok) throw new Error(await schemaRes.text());
        if (!metricsRes.ok) throw new Error(await metricsRes.text());
        const schema = await schemaRes.json();
        const metrics = await metricsRes.json();
        const entry = activeStreams.get(streamId);
        if (entry) {
          if (schema && Object.keys(schema).length) {
            entry.schema = schema;
          }
          entry.metrics = metrics;
          entry.status = metrics.status || 'LIVE';
          if (metrics.created_at && !Number.isNaN(Date.parse(metrics.created_at))) {
            entry.createdAt = new Date(metrics.created_at).getTime();
          }
          if (metrics.latency_ms != null) {
            entry.latencyHistory.push(metrics.latency_ms);
            if (entry.latencyHistory.length > 20) entry.latencyHistory.shift();
          }
          if (currentStreamId === streamId) renderStreamDetail(entry);
        }
      } catch (err) {
        console.warn('Metrics fetch failed', err);
      } finally {
        setTimeout(() => pollStreamData(streamId), 10000);
      }
    }

    function loadStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      currentStreamId = streamId;
      renderSessions();
      renderStreamDetail(entry);
    }

    function renderStreamDetail(stream) {
      const interval = stream.spec.interval_sec || 1;
      const createdSource = stream.metrics?.created_at || stream.spec.created_at;
      const created = createdSource ? new Date(createdSource) : null;
      let latencyValue = stream.metrics?.mean_latency_ms;
      if (latencyValue == null && stream.latencyHistory.length) {
        const sum = stream.latencyHistory.reduce((acc, val) => acc + val, 0);
        latencyValue = sum / stream.latencyHistory.length;
      }
      const latency = latencyValue != null ? `${latencyValue.toFixed(1)} ms` : '—';
      const latestPrice = extractRepresentativePrice(stream.lastEvent);
      const currentTick = stream.metrics?.current_tick || stream.lastEvent?.ts || stream.lastEvent?.window_end || '—';
      const eventsPerMinute = stream.metrics?.events_last_minute ?? '—';
      const dropped = stream.metrics?.dropped ?? '—';
      let uptime = stream.metrics?.uptime;
      if (!uptime && stream.createdAt) {
        const diffMs = Date.now() - stream.createdAt;
        uptime = formatDuration(diffMs);
      }
      uptime = uptime || '—';
      const subscribers = stream.metrics?.subscribers ?? '—';

      if (headerSummary) {
        headerSummary.innerHTML = `
          <h2>${escapeHtml((stream.spec.symbols || []).join(', ') || stream.streamId)}</h2>
          <div style="display:flex;gap:18px;font-size:13px;color:var(--text-muted);">
            <span>Stream ID: ${escapeHtml(stream.streamId)}</span>
            <span>Interval: ${interval}s</span>
            <span>Latency: ${latency}</span>
            <span>Created: ${created ? created.toISOString() : '—'}</span>
          </div>
        `;
      }

      streamStatus.style.display = 'inline-flex';
      streamStatus.textContent = stream.status;
      streamStatus.className = 'status-pill ' + (stream.status.toUpperCase().includes('STOP') ? 'error' : stream.status.toUpperCase().includes('PAUSE') ? 'warn' : '');

      const schemaToRender = stream.schema && Object.keys(stream.schema).length ? stream.schema : (stream.derivedSchema || {});

      detailBody.innerHTML = `
        <div class="panel">
          <h3>Stream Metadata</h3>
          <dl>
            <dt>Stream ID</dt><dd>${escapeHtml(stream.streamId)}</dd>
            <dt>Status</dt><dd>${escapeHtml(stream.status)}</dd>
            <dt>Interval</dt><dd>${interval}s</dd>
            <dt>Latency</dt><dd>${latency}</dd>
            <dt>Created</dt><dd>${created ? created.toISOString() : '—'}</dd>
            <dt>Symbols</dt><dd>${escapeHtml((stream.spec.symbols || []).join(', '))}</dd>
            <dt>Sources</dt><dd>${escapeHtml((stream.spec.sources || []).map(s => s.type).join(', '))}</dd>
            <dt>Exchanges</dt><dd>${escapeHtml((stream.spec.sources || []).flatMap(s => s.exchange ? [s.exchange.toUpperCase()] : []).join(', ') || 'BINANCEUS')}</dd>
            <dt>Driver Stream</dt><dd>CCXT</dd>
            <dt>Type</dt><dd>AggregatedEvent</dd>
            <dt>Last price</dt><dd>${latestPrice != null ? '$' + latestPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}</dd>
          </dl>
        </div>
        <div class="panel">
          <h3>Data Schema</h3>
          <div style="max-height:220px;overflow:auto;font-family:var(--mono);font-size:12px;border:1px solid rgba(59,130,246,0.15);border-radius:10px;padding:10px;background:rgba(8,13,23,0.95);">
            ${Object.entries(schemaToRender || {}).map(([field, meta]) => {
              if (typeof meta === 'string') {
                return `<div>${escapeHtml(field)}: ${escapeHtml(meta)}</div>`;
              }
              const descriptor = meta?.type ? escapeHtml(meta.type) : 'unknown';
              const suffix = meta?.optional ? ' (optional)' : '';
              return `<div>${escapeHtml(field)}: ${descriptor}${suffix}</div>`;
            }).join('') || 'Schema unavailable'}
          </div>
          <div style="display:flex;gap:10px;">
            <button class="action-btn" onclick="copySchema('${stream.streamId}', 'json')">Copy Schema JSON</button>
            <button class="action-btn" onclick="copySchema('${stream.streamId}', 'csv')">Copy CSV Header</button>
          </div>
        </div>
        <div class="panel column-merge">
          <h3>Integration Snippets</h3>
          <div class="code-block">
            <button onclick="copySnippet('python-${stream.streamId}')">Copy</button>
            <pre><code id="python-${stream.streamId}"></code></pre>
          </div>
          <div class="code-block">
            <button onclick="copySnippet('ws-${stream.streamId}')">Copy</button>
            <pre><code id="ws-${stream.streamId}"></code></pre>
          </div>
          <div class="code-block">
            <button onclick="copySnippet('curl-${stream.streamId}')">Copy</button>
            <pre><code id="curl-${stream.streamId}"></code></pre>
          </div>
        </div>
        <div class="panel">
          <h3>Live Metrics</h3>
          <div class="metrics-grid">
            <div><span>Current tick</span>${escapeHtml(String(currentTick))}</div>
            <div><span>Events (60s)</span>${eventsPerMinute}</div>
            <div><span>Mean latency</span>${latency}</div>
            <div><span>Dropped packets</span>${dropped}</div>
            <div><span>Uptime</span>${uptime}</div>
            <div><span>Subscribers</span>${subscribers}</div>
          </div>
          <div class="sparkline-container" id="latencySpark-${stream.streamId}">
            <canvas></canvas>
          </div>
          <div style="display:flex;gap:10px;">
            <button class="action-btn" onclick="refreshMetrics('${stream.streamId}')">Refresh</button>
            <button class="action-btn" onclick="exportData('${stream.streamId}', 'csv')">Export CSV (1h)</button>
            <button class="action-btn" onclick="exportData('${stream.streamId}', 'parquet')">Export Parquet</button>
          </div>
        </div>
        <div class="panel">
          <h3>Actions</h3>
          <div class="actions-list">
            <div class="action-btn" onclick="restartStream('${stream.streamId}')">Restart Stream</div>
            <div class="action-btn" onclick="duplicateStream('${stream.streamId}')">Duplicate Spec</div>
            <div class="action-btn" onclick="downloadSpec('${stream.streamId}')">Download Spec JSON</div>
            <div class="action-btn danger" onclick="stopStream('${stream.streamId}')">Stop Stream</div>
          </div>
        </div>
      `;

      const pythonSnippet = `from bond import listen\n\nasync def main():\n    async for event in listen("${stream.streamId}"):\n        print(event)`;
      const wsActual = stream.wsUrl.replace('localhost', window.location.hostname);
      const wsDisplay = wsActual.replace(/token=.*$/i, 'token=***');
      const curlSnippet = `curl -X GET "https://api.bond.dev/v1/streams/${stream.streamId}" \\\n     -H "Authorization: Bearer <token>"`;

      setSnippet(`python-${stream.streamId}`, 'python', pythonSnippet);
      setSnippet(`ws-${stream.streamId}`, 'url', wsActual, wsDisplay);
      setSnippet(`curl-${stream.streamId}`, 'shell', curlSnippet);

      requestAnimationFrame(() => renderLatencySparkline(stream));
    }

    function copySchema(streamId, type) {
      const entry = activeStreams.get(streamId);
      if (!entry || !entry.schema) return;
      if (type === 'json') {
        navigator.clipboard.writeText(JSON.stringify(entry.schema, null, 2));
      } else {
        navigator.clipboard.writeText(Object.keys(entry.schema).join(','));
      }
    }

    function highlightSnippet(lang, code) {
      let escaped = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      const apply = (regex, cls) => {
        escaped = escaped.replace(regex, `<span class="${cls}">$1</span>`);
      };

      if (lang === 'python') {
        apply(/\b(async|await|for|in|from|import|print|return|def|class|with|as|yield|if|else|elif)\b/g, 'kw');
        apply(/\b(True|False|None)\b/g, 'const');
        apply(/(&quot;.*?&quot;)/g, 'str');
        apply(/(&#39;.*?&#39;)/g, 'str');
        apply(/(#.*?$)/gm, 'comment');
      } else if (lang === 'shell') {
        apply(/^(curl)/gm, 'cmd');
        apply(/\s(-{1,2}\w+)/g, 'flag');
        apply(/(https?:\/\/[^\s]+)/g, 'str');
        apply(/(".*?")/g, 'str');
      } else if (lang === 'url') {
        apply(/(wss?:\/\/[^\s]+)/g, 'str');
        apply(/(token=)([^\s]+)/g, 'flag');
      }

      escaped = escaped
        .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
        .replace(/  /g, '&nbsp;&nbsp;')
        .replace(/\n/g, '<br>');

      return escaped;
    }

    function setSnippet(elementId, lang, code, displayCode = null) {
      const node = document.getElementById(elementId);
      if (!node) return;
      node.dataset.snippet = code;
      const toRender = displayCode == null ? code : displayCode;
      node.innerHTML = highlightSnippet(lang, toRender);
    }

    function copySnippet(elementId) {
      const node = document.getElementById(elementId);
      if (!node) return;
      const text = node.dataset.snippet || node.innerText || '';
      navigator.clipboard.writeText(text);
    }

    function extractRepresentativePrice(event) {
      if (!event) return null;
      if (typeof event.price_close === 'number') return event.price_close;
      if (typeof event.price_avg === 'number') return event.price_avg;
      const exchangeData = event.raw_data?.exchange_data;
      if (exchangeData) {
        for (const exchange of Object.keys(exchangeData)) {
          const symbols = exchangeData[exchange]?.symbols || {};
          for (const symbol of Object.keys(symbols)) {
            const price = symbols[symbol]?.price;
            if (typeof price === 'number') return price;
          }
        }
      }
      return null;
    }

    function deriveSchemaFromEvent(event) {
      if (!event || typeof event !== 'object') return null;
      const result = {};
      for (const [key, value] of Object.entries(event)) {
        result[key] = inferType(value);
      }
      return result;
    }

    function inferType(value) {
      if (value === null || value === undefined) return { type: 'unknown', optional: true };
      if (typeof value === 'number') {
        return { type: Number.isInteger(value) ? 'int' : 'float' };
      }
      if (typeof value === 'string') return { type: 'string' };
      if (typeof value === 'boolean') return { type: 'bool' };
      if (Array.isArray(value)) return { type: 'array' };
      if (value instanceof Date) return { type: 'datetime' };
      if (typeof value === 'object') {
        return { type: 'object', optional: false };
      }
      return { type: typeof value };
    }

    function formatDuration(milliseconds) {
      if (!Number.isFinite(milliseconds) || milliseconds < 0) return null;
      const totalSeconds = Math.floor(milliseconds / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const parts = [];
      if (hours) parts.push(`${hours}h`);
      if (minutes) parts.push(`${minutes}m`);
      if (!parts.length || seconds) parts.push(`${seconds}s`);
      return parts.join(' ');
    }

    async function refreshMetrics(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch(`/v1/streams/${streamId}/metrics`);
        if (!response.ok) throw new Error(await response.text());
        entry.metrics = await response.json();
        renderStreamDetail(entry);
      } catch (err) {
        appendMessage('agent', `Unable to refresh metrics: ${escapeHtml(err.message)}`);
      }
    }

    async function exportData(streamId, format) {
      try {
        const response = await fetch(`/v1/streams/${streamId}/export?format=${format}`);
        if (!response.ok) throw new Error(await response.text());
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${streamId}.${format}`;
        link.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        appendMessage('agent', `Export failed: ${escapeHtml(err.message)}`);
      }
    }

    async function restartStream(streamId) {
      const entry = activeStreams.get(streamId);
      try {
        await fetch(`/v1/streams/${streamId}/restart`, { method: 'PATCH' });
        appendMessage('agent', `Stream ${escapeHtml(streamId)} restarted.`);
        if (entry?.socket) {
          entry.socket.close();
          entry.socket = null;
        }
        if (entry) {
          entry.status = 'CONNECTING';
          openStreamSocket(entry);
        }
        refreshMetrics(streamId);
      } catch (err) {
        appendMessage('agent', `Restart failed: ${escapeHtml(err.message)}`);
      }
    }

    async function duplicateStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch('/v1/streams', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ spec: entry.spec }),
        });
        if (!response.ok) throw new Error(await response.text());
        const stream = await response.json();
        appendMessage('agent', `Duplicated stream as <code>${escapeHtml(stream.stream_id)}</code>.`);
        addSession(stream.stream_id, stream.ws_url, entry.spec);
        loadStream(stream.stream_id);
      } catch (err) {
        appendMessage('agent', `Duplicate failed: ${escapeHtml(err.message)}`);
      }
    }

    async function downloadSpec(streamId) {
      try {
        const response = await fetch(`/v1/streams/${streamId}/spec`);
        if (!response.ok) throw new Error(await response.text());
        const spec = await response.json();
        const blob = new Blob([JSON.stringify(spec, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${streamId}_spec.json`;
        link.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        appendMessage('agent', `Spec download failed: ${escapeHtml(err.message)}`);
      }
    }

    async function stopStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        await fetch(`/v1/streams/${streamId}`, { method: 'DELETE' });
        appendMessage('agent', `Stream ${escapeHtml(streamId)} stopped.`);
        if (entry.socket) {
          entry.socket.close();
          entry.socket = null;
        }
        activeStreams.delete(streamId);
        if (streamId === currentStreamId) {
          currentStreamId = null;
          detailBody.innerHTML = '<div class="panel column-merge" style="text-align:center;opacity:0.6;"><h3>Stream stopped</h3><p style="font-size:13px;color:var(--text-muted);">Select another stream or launch a new one.</p></div>';
          streamStatus.style.display = 'none';
        }
        renderSessions();
      } catch (err) {
        appendMessage('agent', `Failed to stop stream: ${escapeHtml(err.message)}`);
      }
    }

    function renderLatencySparkline(stream) {
      const container = document.getElementById(`latencySpark-${stream.streamId}`);
      if (!container) return;
      const canvas = container.querySelector('canvas');
      const ctx = canvas.getContext('2d');
      const chartData = stream.latencyHistory.slice(-20);
      if (!chartData.length) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'var(--text-muted)';
        ctx.font = '11px var(--mono)';
        ctx.fillText('No latency samples yet', 10, 28);
        return;
      }
      const maxLatency = Math.max(...chartData);
      const minLatency = Math.min(...chartData);
      const span = maxLatency - minLatency || 1;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(59,130,246,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      chartData.forEach((value, idx) => {
        const x = (idx / (chartData.length - 1)) * canvas.width;
        const y = canvas.height - ((value - minLatency) / span) * (canvas.height - 4) - 2;
        if (idx === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    document.addEventListener('keydown', (event) => {
      if (event.metaKey && event.key.toLowerCase() === 'n') {
        event.preventDefault();
        messageInput.focus();
      }
      if (event.metaKey && event.key.toLowerCase() === 'k') {
        event.preventDefault();
        pauseAll = !pauseAll;
        appendMessage('agent', pauseAll ? 'All streams paused (not yet implemented).' : 'Resume streams (not yet implemented).');
      }
    });

    appendMessage('agent', `Bond Agent ready.
    <div style="margin-top:12px;font-size:12px;color:var(--text-muted);">
      Try: “Stream BTC/USDT every 5 seconds.”
    </div>`);
  </script>
</body>
</html>

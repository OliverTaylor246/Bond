<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Echo Terminal · Stream Console</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #07070a;
      --panel: #05070c;
      --panel-strong: #161c26;
      --panel-ghost: rgba(36, 39, 43, 0.82);
      --border: rgba(74, 82, 90, 0.55);
      --border-soft: rgba(62, 120, 178, 0.32);
      --accent: #004ba8;
      --accent-alt: #3e78b2;
      --accent-soft: rgba(62, 120, 178, 0.2);
      --accent-strong: rgba(0, 75, 168, 0.45);
      --success: #2dd4bf;
      --warn: #fbbf24;
      --error: #f87171;
      --text: #f3f6ff;
      --text-muted: #97a3ba;
      --mono: 'JetBrains Mono', monospace;
      --glow: rgba(0, 75, 168, 0.3);
      --gradient-radial: radial-gradient(135% 160% at 50% 0%, rgba(62, 120, 178, 0.24), rgba(7, 7, 10, 0.92));
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--gradient-radial), var(--bg);
      color: var(--text);
      font-family: 'Inter', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      height: 72px;
      background: linear-gradient(135deg, rgba(36, 39, 43, 0.95), rgba(7, 7, 10, 0.94));
      border-bottom: 1px solid rgba(62, 120, 178, 0.28);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 32px;
      padding: 0 36px;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 14px 40px rgba(4, 6, 12, 0.6);
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .brand h1 {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: -0.02em;
    }

    .brand span {
      font-size: 13px;
      color: rgba(247, 249, 255, 0.65);
    }

    .nav-link {
      appearance: none;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-muted);
      font-size: 14px;
      font-weight: 500;
      padding: 8px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.18s ease;
    }

    .nav-link:hover {
      color: var(--text);
      border-color: rgba(0, 75, 168, 0.4);
    }

    .nav-link.active {
      color: var(--text);
      background: var(--accent-soft);
      border-color: var(--accent-strong);
      box-shadow: 0 12px 24px rgba(0, 75, 168, 0.25);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-left: auto;
    }

    .toolbar button,
    .toolbar a {
      border: 1px solid rgba(62, 120, 178, 0.28);
      background: rgba(36, 39, 43, 0.78);
      color: var(--text);
      font-size: 13px;
      padding: 8px 14px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      text-decoration: none;
      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
    }

    .toolbar a {
      text-decoration: none;
    }

    .toolbar button.primary {
      background: linear-gradient(135deg, rgba(0, 75, 168, 0.85), rgba(62, 120, 178, 0.85));
      border-color: rgba(0, 75, 168, 0.45);
      box-shadow: 0 14px 38px rgba(0, 75, 168, 0.35);
    }

    .toolbar button:hover,
    .toolbar a:hover {
      transform: translateY(-1px);
      border-color: rgba(0, 75, 168, 0.45);
      background: rgba(36, 39, 43, 0.92);
    }

    .toolbar button.primary:hover {
      transform: translateY(-2px);
    }

    main {
      flex: 1;
      display: flex;
      gap: 28px;
      padding: 36px;
      min-height: 0;
    }

    .left-pane {
      width: 360px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 22px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 24px 60px rgba(4, 6, 12, 0.55);
    }

    .session-list {
      padding: 22px 22px 18px;
      border-bottom: 1px solid rgba(62, 120, 178, 0.16);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .session-list h2 {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(247, 249, 255, 0.75);
    }

    #sessionNewBtn {
      border: 1px solid rgba(62,120,178,0.32);
      background: rgba(62,120,178,0.18);
      color: var(--accent);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    #sessionNewBtn:hover {
      background: rgba(62,120,178,0.26);
    }

    .sessions {
      flex: 0 0 auto;
      max-height: 220px;
      overflow-y: auto;
      padding: 18px 22px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .session-item {
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(62,120,178,0.18);
      background: rgba(36, 39, 43, 0.7);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
    }

    .session-item:hover,
    .session-item.active {
      transform: translateY(-2px);
      border-color: rgba(0,75,168,0.38);
      background: rgba(62,120,178,0.22);
    }

    .session-item span {
      font-size: 12px;
      color: var(--text-muted);
    }

    .session-empty {
      padding: 32px 0;
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .chat-log {
      flex: 1;
      overflow-y: auto;
      padding: 22px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      border-top: 1px solid rgba(62, 120, 178, 0.14);
      border-bottom: 1px solid rgba(62, 120, 178, 0.14);
      background: rgba(24, 29, 38, 0.7);
    }

    .chat-msg {
      display: flex;
      gap: 10px;
      font-size: 13px;
      animation: fadeIn 0.12s ease-out;
    }

    .chat-msg.agent {
      flex-direction: row;
    }

    .chat-msg.user {
      flex-direction: row-reverse;
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: 10px;
      display: grid;
      place-items: center;
      background: var(--accent-soft);
      font-family: var(--mono);
      font-size: 11px;
      letter-spacing: 0.08em;
      color: var(--accent);
    }

    .chat-msg.agent .avatar {
      background: rgba(0,75,168,0.45);
      color: #f2f7ff;
    }

    .bubble {
      max-width: 82%;
      background: rgba(24, 29, 38, 0.95);
      border: 1px solid rgba(62, 120, 178, 0.22);
      border-radius: 14px;
      padding: 12px 14px;
      line-height: 1.58;
      color: var(--text);
      box-shadow: 0 10px 28px rgba(4, 6, 12, 0.45);
    }

    .chat-msg.user .bubble {
      background: rgba(0,75,168,0.18);
      border-color: rgba(0,75,168,0.32);
      color: #e7f0ff;
    }

    .chat-input {
      padding: 18px 22px 22px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: rgba(20, 25, 33, 0.88);
    }

    .chat-input textarea {
      min-height: 130px;
      resize: none;
      border-radius: 14px;
      background: rgba(14, 18, 26, 0.9);
      border: 1px solid rgba(62,120,178,0.24);
      color: var(--text);
      padding: 12px 14px;
      font-size: 13px;
      line-height: 1.6;
    }

    .chat-input textarea:focus {
      outline: none;
      border-color: rgba(0,75,168,0.5);
      box-shadow: 0 0 0 1px rgba(0,75,168,0.2);
      background: rgba(20, 26, 36, 0.95);
    }

    .chat-input button {
      align-self: flex-end;
      border-radius: 12px;
      border: 1px solid rgba(62,120,178,0.32);
      background: rgba(62,120,178,0.22);
      color: #e2ecff;
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .chat-input button:hover {
      background: rgba(62,120,178,0.32);
    }

    .detail-pane {
      flex: 1;
      background: var(--panel-strong);
      border: 1px solid var(--border);
      border-radius: 24px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 24px 60px rgba(4, 6, 12, 0.55);
    }

    .detail-header {
      padding: 26px 30px;
      border-bottom: 1px solid rgba(62,120,178,0.18);
      background: rgba(24, 29, 38, 0.9);
      display: flex;
      justify-content: space-between;
      gap: 32px;
      align-items: flex-start;
    }

    .detail-header .summary {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .detail-header h2 {
      font-size: 24px;
      font-weight: 600;
      letter-spacing: -0.015em;
    }

    .detail-header .summary div {
      display: flex;
      gap: 18px;
      font-size: 13px;
      color: var(--text-muted);
      flex-wrap: wrap;
    }

    .detail-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 12px;
    }

    .detail-controls .streams-actions button {
      padding: 6px 14px;
    }

    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-family: var(--mono);
      font-size: 12px;
      padding: 7px 14px;
      border-radius: 999px;
      border: 1px solid var(--accent-strong);
      background: var(--accent-soft);
      color: #f1f7ff;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .status-pill.warn {
      background: rgba(245, 158, 11, 0.18);
      border-color: rgba(245, 158, 11, 0.38);
      color: #fde68a;
    }

    .status-pill.error {
      background: rgba(248, 113, 113, 0.18);
      border-color: rgba(248, 113, 113, 0.38);
      color: #fecdd3;
    }

    .detail-body {
      padding: 28px 30px 32px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 22px;
      align-items: start;
      overflow-y: auto;
      max-height: calc(100vh - 72px - 110px);
      background: rgba(11, 14, 20, 0.88);
    }

    .panel {
      background: rgba(19, 23, 31, 0.95);
      border: 1px solid rgba(62,120,178,0.22);
      border-radius: 20px;
      padding: 22px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      box-shadow: 0 18px 44px rgba(4, 6, 12, 0.45);
    }

    .panel h3 {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #d8e5f5;
    }

    .panel dl {
      display: grid;
      grid-template-columns: minmax(120px, 0.4fr) 1fr;
      row-gap: 12px;
      column-gap: 14px;
      font-size: 13px;
    }

    .panel dt {
      color: var(--text-muted);
      font-family: var(--mono);
      letter-spacing: 0.02em;
    }

    .panel dd {
      font-family: var(--mono);
      color: #e5e9ff;
    }

    .source-schema-block {
      border: 1px solid rgba(62,120,178,0.2);
      border-radius: 16px;
      padding: 14px 16px;
      background: rgba(8, 12, 18, 0.72);
      margin-top: 12px;
    }

    .source-schema-title {
      font-size: 13px;
      font-weight: 600;
      color: #f1f5ff;
      margin-bottom: 10px;
    }

    .source-schema-grid {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
    }

    .source-schema-field {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(62,120,178,0.12);
    }

    .source-schema-field:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .source-schema-field span:first-child {
      font-family: var(--mono);
      color: #e0e7ff;
    }

    .source-schema-field span:last-child {
      color: #c3cfe4;
      text-align: right;
    }

    .code-block {
      background: rgba(14, 18, 26, 0.95);
      border: 1px solid rgba(62,120,178,0.22);
      border-radius: 14px;
      padding: 14px 0 0;
      position: relative;
      overflow: hidden;
    }

    .code-block button {
      position: absolute;
      top: 12px;
      right: 12px;
      border: 1px solid rgba(62,120,178,0.35);
      background: rgba(62,120,178,0.18);
      color: #e0ecff;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 11px;
      cursor: pointer;
    }

    .code-block pre {
      margin: 0;
      padding: 20px 20px 18px;
      overflow-x: auto;
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.6;
      color: #d4e1f3;
    }

    .code-block .kw { color: #9ac7ff; }
    .code-block .const { color: #f9a8d4; }
    .code-block .str { color: #bef264; }
    .code-block .cmd { color: #facc15; }
    .code-block .flag { color: #fca5a5; }
    .code-block .comment { color: #8695ad; }

    .actions-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .action-btn {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid rgba(62,120,178,0.28);
      background: rgba(24, 29, 38, 0.82);
      padding: 12px 16px;
      border-radius: 14px;
      font-size: 13px;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.15s ease, border-color 0.15s ease;
    }

    .action-btn:hover {
      background: rgba(62,120,178,0.24);
      transform: translateY(-1px);
    }

    .action-btn.danger {
      border-color: rgba(248,113,113,0.45);
      background: rgba(127, 29, 29, 0.28);
      color: #fecaca;
    }

    .column-merge {
      grid-column: 1 / -1;
    }

    .streams-view {
      display: none;
      flex-direction: column;
      flex: 1;
      gap: 24px;
      background: rgba(11, 14, 20, 0.78);
      border: 1px solid var(--border);
      border-radius: 24px;
      padding: 32px;
      box-shadow: 0 24px 60px rgba(4, 6, 12, 0.5);
    }

    .streams-hero {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .streams-hero h2 {
      font-size: 24px;
      font-weight: 600;
      letter-spacing: -0.015em;
    }

    .streams-hero-headline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }

    .streams-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .streams-actions button {
      border: 1px solid rgba(62,120,178,0.32);
      background: rgba(62,120,178,0.16);
      color: #e0ecff;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .streams-actions button:hover {
      background: rgba(62,120,178,0.26);
    }

    .streams-hero p {
      font-size: 14px;
      color: var(--text-muted);
      max-width: 560px;
    }

    .streams-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px;
    }

    .stream-card {
      border: 1px solid rgba(62,120,178,0.24);
      background: rgba(24, 29, 38, 0.82);
      border-radius: 20px;
      padding: 22px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
      box-shadow: 0 18px 44px rgba(4, 6, 12, 0.45);
    }

    .stream-card:hover {
      transform: translateY(-4px);
      border-color: rgba(0,75,168,0.45);
      background: rgba(36, 42, 52, 0.92);
    }

    .stream-card.active {
      border-color: rgba(0,75,168,0.55);
      box-shadow: 0 20px 48px rgba(0,75,168,0.28);
    }

    .stream-card header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
    }

    .stream-card header h3 {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: -0.01em;
    }

    .stream-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .stream-meta span {
      display: block;
    }

    .stream-card footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: var(--text-muted);
    }

    .stream-card footer button {
      border: 1px solid rgba(62,120,178,0.35);
      background: rgba(62,120,178,0.22);
      color: #e0ecff;
      padding: 6px 12px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
    }

    .stream-empty {
      padding: 40px 24px;
      border: 1px dashed rgba(62,120,178,0.3);
      border-radius: 18px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }

    body.view-chat main {
      justify-content: flex-start;
      align-items: stretch;
    }

    body.view-chat .left-pane {
      width: 100%;
      max-width: none;
      flex: 1;
      border-radius: 28px;
      border: 1px solid rgba(62,120,178,0.28);
    }

    body.view-chat .session-list,
    body.view-chat .sessions {
      display: none;
    }

    body.view-chat .chat-log {
      flex: 1;
      min-height: 420px;
      max-height: none;
      border-radius: 18px;
    }

    body.view-chat .chat-input {
      border-radius: 0 0 28px 28px;
    }

    body.view-chat .detail-pane {
      display: none;
    }

    body.view-chat #streamsView {
      display: none;
    }

    body.view-streams main {
      justify-content: center;
    }

    body.view-streams .left-pane,
    body.view-streams .detail-pane {
      display: none;
    }

    body.view-streams #streamsView {
      display: flex;
      max-width: 1100px;
    }

    body.view-stream-detail #streamsView {
      display: none;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(4px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 1200px) {
      header {
        flex-wrap: wrap;
        height: auto;
        padding: 16px 24px;
        gap: 16px;
      }

      .toolbar {
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      main {
        flex-direction: column;
        padding: 24px;
      }

      .left-pane {
        width: 100%;
      }

      .detail-pane {
        width: 100%;
      }

      .detail-body {
        grid-template-columns: 1fr;
      }

      body.view-streams #streamsView {
        max-width: none;
      }
    }

    @media (max-width: 768px) {
      .toolbar {
        width: 100%;
        justify-content: center;
      }

      .toolbar button,
      .toolbar a {
        flex: 1;
        justify-content: center;
      }

      .streams-grid {
        grid-template-columns: 1fr;
      }

      .chat-log {
        max-height: none;
      }
    }
  </style>
</head>
<body class="view-chat">
  <header>
    <div class="brand">
      <h1>3KKO</h1>
    </div>
    <div class="toolbar">
      <button class="nav-link active" id="navChat">Chat</button>
      <button class="nav-link" id="navStreams">Streams</button>
      <a class="nav-link" href="https://docs.example.com" target="_blank" rel="noreferrer">Docs</a>
      <button class="nav-link" id="toolbarSettings">Settings</button>
      <button class="primary" id="toolbarNew">New Stream</button>
      <div id="auth-status" style="margin-left: 16px; display: none; align-items: center; gap: 8px;">
        <span id="user-email-display" style="color: var(--text-muted); font-size: 13px;"></span>
        <button id="logout-btn" style="border: 1px solid rgba(148,163,184,0.35); background: rgba(148,163,184,0.12); color: var(--text); font-size: 12px; padding: 6px 12px; border-radius: 8px; cursor: pointer;">Sign Out</button>
      </div>
      <a id="login-link" href="/login" style="margin-left: 16px; display: none; border: 1px solid rgba(59,130,246,0.35); background: rgba(59,130,246,0.15); color: var(--text); font-size: 13px; padding: 6px 12px; border-radius: 8px; text-decoration: none;">Sign In</a>
    </div>
  </header>

  <main>
    <aside class="left-pane">
      <div class="session-list">
        <h2>Streams</h2>
        <button id="sessionNewBtn">New</button>
      </div>
      <div class="sessions" id="sessionList"></div>
      <div class="chat-log" id="chatLog"></div>
      <form class="chat-input" id="chatForm">
        <textarea id="messageInput" placeholder="Ask Echo Agent to create or modify streams…" rows="4"></textarea>
        <button type="submit">Submit</button>
      </form>
    </aside>

    <section class="detail-pane" id="detailPane">
      <div class="detail-header" id="streamHeader">
        <div class="summary">
          <h2>Select a stream to view details</h2>
          <div style="display:flex;gap:18px;font-size:13px;color:var(--text-muted);">
            <span>No stream loaded</span>
          </div>
        </div>
        <div class="detail-controls">
          <div class="streams-actions detail-actions">
            <button data-action="pause-all">Pause All</button>
          </div>
          <span class="status-pill" id="streamStatus" style="display:none;">• LIVE</span>
        </div>
      </div>
      <div class="detail-body" id="detailBody">
        <div class="panel column-merge" style="text-align:center;opacity:0.6;">
          <h3 style="margin-bottom:10px;">Awaiting Selection</h3>
          <p style="font-size:13px;color:var(--text-muted);">
            Use Echo Agent to launch a stream or select one from the Sessions list to inspect its metadata, schema, integrations, and performance metrics.
          </p>
        </div>
      </div>
    </section>
    <section class="streams-view" id="streamsView">
      <div class="streams-hero">
        <div class="streams-hero-headline">
          <h2>Active Streams</h2>
          <div class="streams-actions">
            <button data-action="pause-all">Pause All</button>
          </div>
        </div>
        <p>Launch new streams from the chat, then jump back in here to inspect performance and metadata.</p>
      </div>
      <div class="streams-grid" id="streamsDirectory"></div>
    </section>
  </main>

  <script>
    const chatLog = document.getElementById('chatLog');
    const chatForm = document.getElementById('chatForm');
    const messageInput = document.getElementById('messageInput');
    const sessionList = document.getElementById('sessionList');
    const detailHeader = document.getElementById('streamHeader');
    const headerSummary = detailHeader.querySelector('.summary');
    const detailBody = document.getElementById('detailBody');
    const streamStatus = document.getElementById('streamStatus');
    const streamsView = document.getElementById('streamsView');
    const streamsDirectory = document.getElementById('streamsDirectory');
    const navChat = document.getElementById('navChat');
    const navStreams = document.getElementById('navStreams');
    const root = document.body;
    const VIEW_CHAT = 'chat';
    const VIEW_STREAMS = 'streams';
    const VIEW_DETAIL = 'stream-detail';
    const viewClasses = ['view-chat', 'view-streams', 'view-stream-detail'];

    const activeStreams = new Map();
    let currentStreamId = null;
    let pauseAll = false;

    function escapeHtml(str = '') {
      return str.replace(/[&<>"]+/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]));
    }

    function setView(nextView) {
      if (![VIEW_CHAT, VIEW_STREAMS, VIEW_DETAIL].includes(nextView)) {
        nextView = VIEW_CHAT;
      }
      currentView = nextView;
      root.classList.remove(...viewClasses);
      root.classList.add(`view-${nextView}`);
      if (navChat) {
        navChat.classList.toggle('active', nextView === VIEW_CHAT);
      }
      if (navStreams) {
        navStreams.classList.toggle('active', nextView === VIEW_STREAMS || nextView === VIEW_DETAIL);
      }
      if (nextView === VIEW_STREAMS && streamsView) {
        streamsView.scrollTop = 0;
      }
      if (nextView === VIEW_CHAT && messageInput) {
        messageInput.focus({ preventScroll: true });
      }
    }

    if (navChat) {
      navChat.addEventListener('click', (event) => {
        event.preventDefault();
        setView(VIEW_CHAT);
      });
    }

    if (navStreams) {
      navStreams.addEventListener('click', (event) => {
        event.preventDefault();
        setView(VIEW_STREAMS);
        renderStreamsDirectory();
      });
    }

    if (streamsDirectory) {
      streamsDirectory.addEventListener('click', (event) => {
        const target = event.target.closest('[data-stream]');
        if (!target) return;
        event.preventDefault();
        loadStream(target.dataset.stream);
      });
    }

    function appendMessage(role, html) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chat-msg ' + role;
      wrapper.innerHTML = `
        <div class="avatar">${role === 'agent' ? 'AI' : 'ME'}</div>
        <div class="bubble">${html}</div>
      `;
      chatLog.appendChild(wrapper);
      chatLog.scrollTop = chatLog.scrollHeight;
      return wrapper.querySelector('.bubble');
    }

    const pauseAllButtons = Array.from(document.querySelectorAll('[data-action="pause-all"]'));
    const pollTimers = new Map();

    function setPauseButtonLabels() {
      pauseAllButtons.forEach(btn => {
        btn.textContent = pauseAll ? 'Resume All' : 'Pause All';
      });
    }

    pauseAllButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        pauseAll = !pauseAll;
        appendMessage('agent', pauseAll ? 'All streams paused (not yet implemented).' : 'Resume streams (not yet implemented).');
        setPauseButtonLabels();
      });
    });

    setPauseButtonLabels();

    function cloneSpec(spec) {
      if (!spec) return spec;
      try {
        return structuredClone(spec);
      } catch (err) {
        return JSON.parse(JSON.stringify(spec));
      }
    }

    function getDefaultTargetStreamId() {
      if (currentStreamId && activeStreams.has(currentStreamId)) {
        return currentStreamId;
      }
      const iterator = activeStreams.keys();
      const first = iterator.next();
      return first.done ? null : first.value;
    }

    function shouldRequestNewStream(text) {
      const query = text.toLowerCase();
      return /\b(new|another|separate)\s+(stream|feed)\b/.test(query)
        || query.includes('create a new stream')
        || query.includes('start a new')
        || query.includes('spin up a new')
        || query.includes('brand new stream');
    }

    function applyStreamResponse(stream) {
      if (!stream || !stream.stream_id) return;
      const entry = activeStreams.get(stream.stream_id);
      if (!entry) {
        addSession(stream.stream_id, stream.ws_url, stream.spec);
        return;
      }
      entry.spec = cloneSpec(stream.spec);
      entry.wsUrl = stream.ws_url;
      entry.metrics = null;
      entry.schema = null;
      entry.derivedSchema = null;
      entry.lastEvent = null;
      entry.latencyHistory = [];
      entry.priceHistory = [];
      entry.createdAt = Date.now();
      entry.status = 'CONNECTING';
      if (entry.socket) {
        entry.socket.close();
        entry.socket = null;
      }
      openStreamSocket(entry);
      refreshMetrics(stream.stream_id);
      renderSessions();
      if (currentStreamId === stream.stream_id) {
        renderStreamDetail(entry);
      }
    }

    chatForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      const prompt = messageInput.value.trim();
      if (!prompt) return;

      appendMessage('user', escapeHtml(prompt));
      messageInput.value = '';

      const wantsNewStream = shouldRequestNewStream(prompt);
      const targetStreamId = wantsNewStream ? null : getDefaultTargetStreamId();
      const payload = { query: prompt };
      if (targetStreamId) {
        payload.stream_id = targetStreamId;
      }

      const pending = appendMessage('agent', `Parsing “${escapeHtml(prompt)}”…`);
      try {
        const response = await fetch('/v1/streams/parse', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!response.ok) throw new Error(await response.text());
        const parsed = await response.json();
        renderParseSummary(parsed, pending, targetStreamId, wantsNewStream);
      } catch (err) {
        pending.innerHTML = `
          <div>Error parsing request.</div>
          <div style="margin-top:8px;color:#fca5a5;font-size:13px;">${escapeHtml(err.message)}</div>
        `;
      }
    });

    function renderParseSummary(parsed, bubble, preferredStreamId = null, forcedNew = false) {
      const spec = parsed.spec || { sources: [], symbols: [], interval_sec: 1 };
      const sources = Array.isArray(spec.sources) ? spec.sources : [];
      const ccxtSources = sources.filter(src => src.type === 'ccxt');
      const otherSources = sources.filter(src => src.type !== 'ccxt');

      let targetStreamId = preferredStreamId && activeStreams.has(preferredStreamId)
        ? preferredStreamId
        : null;
      if (!targetStreamId && !forcedNew) {
        targetStreamId = getDefaultTargetStreamId();
      }
      const allowUpdate = Boolean(targetStreamId && activeStreams.has(targetStreamId) && !forcedNew);
      const targetStream = allowUpdate ? activeStreams.get(targetStreamId) : null;
      const targetLabel = targetStream
        ? ` (${escapeHtml((targetStream.spec.symbols || []).join(', ') || targetStreamId.slice(0, 8))})`
        : '';

      const rows = ccxtSources.map(src => `
        <tr>
          <td>${escapeHtml((src.exchange || 'BINANCEUS').toUpperCase())}</td>
          <td>${escapeHtml((src.symbols || []).join(', '))}</td>
          <td>${escapeHtml((src.fields || []).join(', ') || 'price, volume')}</td>
        </tr>
      `).join('');

      const otherRows = otherSources.map(src => {
        let detail = '';
        if (src.type === 'nitter') {
          const handle = src.username ? `@${src.username}` : 'nitter feed';
          const cadence = src.interval_sec ? `${src.interval_sec}s` : `${spec.interval_sec || 1}s`;
          detail = `${handle}, refresh ${cadence}`;
        } else if (src.type === 'google_trends') {
          const keywords = (src.keywords || []).join(', ') || 'auto keywords';
          const timeframe = src.timeframe || 'default window';
          detail = `keywords: ${keywords} • timeframe: ${timeframe}`;
        } else {
          detail = Object.entries(src)
            .filter(([key]) => key !== 'type')
            .map(([key, value]) => `${key}: ${Array.isArray(value) ? value.join(', ') : value}`)
            .join(' • ') || 'No extra config';
        }
        return `
          <tr>
            <td>${escapeHtml(src.type || 'custom')}</td>
            <td>${escapeHtml(detail)}</td>
          </tr>
        `;
      }).join('');

      const ccxtTable = ccxtSources.length ? `
        <table style="margin-top:12px;border-collapse:collapse;width:100%;font-size:12px;">
          <thead>
            <tr style="background:rgba(62,120,178,0.18);">
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Exchange</th>
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Symbols</th>
              <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Fields</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      ` : '';

      const updateNote = allowUpdate
        ? `<div style="margin-top:8px;font-size:12px;color:#9fb3d4;">
            Applying changes to stream <code>${escapeHtml(targetStreamId)}</code>${targetLabel}.
            Choose “Create New Stream” to start a separate feed.
          </div>`
        : '';

      bubble.innerHTML = `
        <div>Here’s the stream I can create:</div>
        ${updateNote}
        ${ccxtTable || ''}
        ${!ccxtTable ? '<div style="margin-top:12px;font-size:12px;color:#94a3b8;">No CCXT exchange sources configured.</div>' : ''}
        ${otherSources.length ? `
          <div style="margin-top:16px;font-size:12px;color:#c3cfe4;">Additional sources</div>
          <table style="margin-top:6px;border-collapse:collapse;width:100%;font-size:12px;">
            <thead>
              <tr style="background:rgba(62,120,178,0.12);">
                <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Type</th>
                <th style="padding:6px 8px;text-align:left;border:1px solid rgba(62,120,178,0.16);">Details</th>
              </tr>
            </thead>
            <tbody>${otherRows}</tbody>
          </table>
        ` : ''}
        <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
          ${allowUpdate ? '<button id="updateStreamBtn" style="border:1px solid rgba(16,185,129,0.45);background:rgba(16,185,129,0.18);color:#d1fae5;padding:8px 12px;border-radius:12px;font-size:12px;cursor:pointer;">Update Stream</button>' : ''}
          <button id="createStreamBtn" style="border:1px solid rgba(0,75,168,0.4);background:rgba(0,75,168,0.22);color:#e0ecff;padding:8px 12px;border-radius:12px;font-size:12px;cursor:pointer;">${allowUpdate ? 'Create New Stream' : 'Launch Stream'}</button>
          <button id="cancelLaunchBtn" style="border:1px solid rgba(148,163,184,0.3);background:rgba(148,163,184,0.12);color:#c3cfe4;padding:8px 12px;border-radius:12px;font-size:12px;cursor:pointer;">Modify</button>
        </div>
      `;

      const createBtn = bubble.querySelector('#createStreamBtn');
      if (createBtn) {
        createBtn.addEventListener('click', async () => {
          bubble.innerHTML = 'Launching stream…';
          try {
            const response = await fetch('/v1/streams', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ spec }),
            });
            if (!response.ok) throw new Error(await response.text());
            const stream = await response.json();
            addSession(stream.stream_id, stream.ws_url, stream.spec);
            bubble.innerHTML = `
              Stream <code>${escapeHtml(stream.stream_id)}</code> started.
              <div style="margin-top:10px;">
                <a href="#" data-open-stream="${stream.stream_id}" style="color:var(--accent);text-decoration:none;">Open stream workspace →</a>
              </div>
            `;
            const openLink = bubble.querySelector('[data-open-stream]');
            if (openLink) {
              openLink.addEventListener('click', (event) => {
                event.preventDefault();
                loadStream(stream.stream_id);
              });
            }
          } catch (err) {
            bubble.innerHTML = `Failed to launch: ${escapeHtml(err.message)}`;
          }
        });
      }

      if (allowUpdate) {
        const updateBtn = bubble.querySelector('#updateStreamBtn');
        if (updateBtn) {
          updateBtn.addEventListener('click', async () => {
            bubble.innerHTML = `Updating stream <code>${escapeHtml(targetStreamId)}</code>…`;
            try {
              const response = await fetch(`/v1/streams/${targetStreamId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ spec }),
              });
              if (!response.ok) throw new Error(await response.text());
              const stream = await response.json();
              applyStreamResponse(stream);
              bubble.innerHTML = `Stream <code>${escapeHtml(stream.stream_id)}</code> updated.`;
            } catch (err) {
              bubble.innerHTML = `Failed to update: ${escapeHtml(err.message)}`;
            }
          });
        }
      }

      const cancelBtn = bubble.querySelector('#cancelLaunchBtn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          bubble.innerHTML = 'Okay — adjust your request and send again.';
        });
      }
    }

    function cancelPoll(streamId) {
      const timer = pollTimers.get(streamId);
      if (timer) {
        clearTimeout(timer);
        pollTimers.delete(streamId);
      }
    }

    function schedulePoll(streamId) {
      cancelPoll(streamId);
      const timer = setTimeout(() => {
        pollTimers.delete(streamId);
        pollStreamData(streamId);
      }, 10000);
      pollTimers.set(streamId, timer);
    }

    function addSession(streamId, wsUrl, spec) {
      const snapshot = cloneSpec(spec);
      const createdAt = snapshot?.created_at ? new Date(snapshot.created_at).getTime() : Date.now();
      activeStreams.set(streamId, {
        streamId,
        wsUrl,
        spec: snapshot,
        metrics: null,
        schema: null,
        derivedSchema: null,
        status: 'LIVE',
        priceHistory: [],
        latencyHistory: [],
        lastEvent: null,
        socket: null,
        createdAt,
      });
      renderSessions();
      const entry = activeStreams.get(streamId);
      if (entry) {
        openStreamSocket(entry);
      }
      cancelPoll(streamId);
      pollStreamData(streamId);
    }

    function openStreamSocket(entry) {
      try {
        entry.status = 'CONNECTING';
        renderSessions();
        const url = entry.wsUrl.replace('localhost', window.location.hostname);
        const socket = new WebSocket(url);
        entry.socket = socket;

        socket.onopen = () => {
          entry.status = 'LIVE';
          renderSessions();
          if (currentStreamId === entry.streamId) renderStreamDetail(entry);
        };

        socket.onmessage = (event) => {
          try {
            const payload = JSON.parse(event.data);
            entry.lastEvent = payload;
            const tsValue = payload.ts || payload.window_end;
            if (tsValue) {
              const ts = new Date(tsValue).getTime();
              entry.latencyHistory.push(Date.now() - ts);
              if (entry.latencyHistory.length > 50) entry.latencyHistory.shift();
            }

            const price = extractRepresentativePrice(payload);
            if (typeof price === 'number' && !Number.isNaN(price)) {
              entry.priceHistory.push(price);
              if (entry.priceHistory.length > 120) entry.priceHistory.shift();
            }
            if (!entry.schema) {
              entry.derivedSchema = deriveSchemaFromEvent(payload);
            }
            if (currentStreamId === entry.streamId) renderStreamDetail(entry);
            renderSessions();
          } catch (err) {
            console.warn('Malformed event', err);
          }
        };

        socket.onerror = () => {
          entry.status = 'ERROR';
          renderSessions();
        };

        socket.onclose = () => {
          entry.socket = null;
          if (entry.status === 'LIVE') {
            entry.status = 'DISCONNECTED';
          }
          renderSessions();
        };
      } catch (err) {
        console.warn('WebSocket failure', err);
        entry.status = 'ERROR';
        renderSessions();
      }
    }

    function renderSessions() {
      const fragments = [];
      for (const [streamId, stream] of activeStreams.entries()) {
        fragments.push(`
          <div class="session-item ${streamId === currentStreamId ? 'active' : ''}" data-stream="${streamId}">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <strong style="font-size:13px;color:#f7f9ff;">${escapeHtml((stream.spec.symbols || []).join(', ') || streamId.slice(0, 8))}</strong>
              <span>${escapeHtml(stream.status)}</span>
            </div>
            <span>ID: ${escapeHtml(streamId)}</span>
            <span>Interval: ${(stream.spec.interval_sec || 1)}s</span>
          </div>
        `);
      }
      sessionList.innerHTML = fragments.join('') || '<div class="session-empty">No streams launched yet.</div>';
      sessionList.querySelectorAll('[data-stream]').forEach(node => node.addEventListener('click', () => loadStream(node.dataset.stream)));
      renderStreamsDirectory();
    }

    function renderStreamsDirectory() {
      if (!streamsDirectory) return;
      const cards = [];
      for (const [streamId, stream] of activeStreams.entries()) {
        const title = (stream.spec.symbols || []).join(', ') || streamId.slice(0, 8);
        const interval = stream.spec.interval_sec || 1;
        let latencyValue = stream.metrics?.mean_latency_ms;
        const latencyHistory = stream.latencyHistory || [];
        if (latencyValue == null && latencyHistory.length) {
          const sum = latencyHistory.reduce((acc, val) => acc + val, 0);
          latencyValue = sum / latencyHistory.length;
        }
        const latency = latencyValue != null ? `${latencyValue.toFixed(1)} ms` : '—';
        const latestPrice = extractRepresentativePrice(stream.lastEvent);
        const priceText = typeof latestPrice === 'number'
          ? `$${latestPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`
          : '—';
        const status = stream.status || 'LIVE';
        const statusClass = status.toUpperCase().includes('STOP')
          ? 'status-pill error'
          : status.toUpperCase().includes('PAUSE')
            ? 'status-pill warn'
            : 'status-pill';
        const eventsPerMinute = stream.metrics?.events_last_minute ?? '—';
        const isActive = streamId === currentStreamId;
        cards.push(`
          <article class="stream-card${isActive ? ' active' : ''}" data-stream="${streamId}">
            <header>
              <h3>${escapeHtml(title)}</h3>
              <span class="${statusClass}">${escapeHtml(status)}</span>
            </header>
            <div class="stream-meta">
              <span>Interval: ${interval}s</span>
              <span>Latency: ${latency}</span>
              <span>Events (60s): ${eventsPerMinute}</span>
              <span>Last price: ${escapeHtml(priceText)}</span>
            </div>
            <footer>
              <span>ID: ${escapeHtml(streamId)}</span>
              <button type="button">Open workspace</button>
            </footer>
          </article>
        `);
      }
      streamsDirectory.innerHTML = cards.join('') || '<div class="stream-empty">No streams launched yet. Use the chat to request one.</div>';
    }

    async function pollStreamData(streamId) {
      if (!activeStreams.has(streamId)) {
        cancelPoll(streamId);
        return;
      }
      try {
        const [schemaRes, metricsRes] = await Promise.all([
          fetch(`/v1/streams/${streamId}/schema`),
          fetch(`/v1/streams/${streamId}/metrics`)
        ]);
        if (!schemaRes.ok) throw new Error(await schemaRes.text());
        if (!metricsRes.ok) throw new Error(await metricsRes.text());
        const schema = await schemaRes.json();
        const metrics = await metricsRes.json();
        const entry = activeStreams.get(streamId);
        if (!entry) return;
        if (schema && Object.keys(schema).length) {
          entry.schema = schema;
        }
        entry.metrics = metrics;
        entry.status = metrics.status || 'LIVE';
        if (metrics.created_at && !Number.isNaN(Date.parse(metrics.created_at))) {
          entry.createdAt = new Date(metrics.created_at).getTime();
        }
        if (metrics.latency_ms != null) {
          entry.latencyHistory.push(metrics.latency_ms);
          if (entry.latencyHistory.length > 20) entry.latencyHistory.shift();
        }
        if (currentStreamId === streamId) renderStreamDetail(entry);
        renderSessions();
      } catch (err) {
        console.warn('Metrics fetch failed', err);
      } finally {
        if (activeStreams.has(streamId)) {
          schedulePoll(streamId);
        } else {
          cancelPoll(streamId);
        }
      }
    }

    function loadStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      currentStreamId = streamId;
      setView(VIEW_DETAIL);
      renderSessions();
      renderStreamDetail(entry);
    }

    function renderStreamDetail(stream) {
      const interval = stream.spec.interval_sec || 1;
      const createdSource = stream.metrics?.created_at || stream.spec.created_at;
      const created = createdSource ? new Date(createdSource) : null;
      let latencyValue = stream.metrics?.mean_latency_ms;
      if (latencyValue == null && stream.latencyHistory.length) {
        const sum = stream.latencyHistory.reduce((acc, val) => acc + val, 0);
        latencyValue = sum / stream.latencyHistory.length;
      }
      const latency = latencyValue != null ? `${latencyValue.toFixed(1)} ms` : '—';
      const latestPrice = extractRepresentativePrice(stream.lastEvent);

      if (headerSummary) {
        headerSummary.innerHTML = `
          <h2>${escapeHtml((stream.spec.symbols || []).join(', ') || stream.streamId)}</h2>
          <div style="display:flex;gap:18px;font-size:13px;color:var(--text-muted);">
            <span>Stream ID: ${escapeHtml(stream.streamId)}</span>
            <span>Interval: ${interval}s</span>
            <span>Latency: ${latency}</span>
            <span>Created: ${created ? created.toISOString() : '—'}</span>
          </div>
        `;
      }

      streamStatus.style.display = 'inline-flex';
      streamStatus.textContent = stream.status;
      streamStatus.className = 'status-pill ' + (stream.status.toUpperCase().includes('STOP') ? 'error' : stream.status.toUpperCase().includes('PAUSE') ? 'warn' : '');

      const schemaToRender = getDisplaySchema(stream);
      const sourceSchemaHtml = renderSourceSchemaBlocks(stream);
      const lastEventJson = stream.lastEvent ? JSON.stringify(stream.lastEvent, null, 2) : null;

      detailBody.innerHTML = `
        <div class="panel">
          <h3>Stream Metadata</h3>
          <dl>
            <dt>Stream ID</dt><dd>${escapeHtml(stream.streamId)}</dd>
            <dt>Status</dt><dd>${escapeHtml(stream.status)}</dd>
            <dt>Interval</dt><dd>${interval}s</dd>
            <dt>Latency</dt><dd>${latency}</dd>
            <dt>Created</dt><dd>${created ? created.toISOString() : '—'}</dd>
            <dt>Symbols</dt><dd>${escapeHtml((stream.spec.symbols || []).join(', '))}</dd>
            <dt>Sources</dt><dd>${escapeHtml((stream.spec.sources || []).map(s => s.type).join(', '))}</dd>
            <dt>Exchanges</dt><dd>${escapeHtml((stream.spec.sources || []).flatMap(s => s.exchange ? [s.exchange.toUpperCase()] : []).join(', ') || 'BINANCEUS')}</dd>
            <dt>Driver Stream</dt><dd>CCXT</dd>
            <dt>Type</dt><dd>AggregatedEvent</dd>
            <dt>Last price</dt><dd>${latestPrice != null ? '$' + latestPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—'}</dd>
          </dl>
        </div>
        <div class="panel">
          <h3>Data Schema</h3>
          <div style="max-height:220px;overflow:auto;font-family:var(--mono);font-size:12px;border:1px solid rgba(62,120,178,0.2);border-radius:12px;padding:12px;background:rgba(19,23,31,0.95);">
            ${Object.entries(schemaToRender || {}).map(([field, meta]) => {
              if (typeof meta === 'string') {
                return `<div>${escapeHtml(field)}: ${escapeHtml(meta)}</div>`;
              }
              const descriptor = meta?.type ? escapeHtml(meta.type) : 'unknown';
              const suffix = meta?.optional ? ' (optional)' : '';
              return `<div>${escapeHtml(field)}: ${descriptor}${suffix}</div>`;
            }).join('') || 'Schema unavailable'}
          </div>
          <div style="display:flex;gap:10px;">
            <button class="action-btn" onclick="copySchema('${stream.streamId}', 'json')">Copy Schema JSON</button>
            <button class="action-btn" onclick="copySchema('${stream.streamId}', 'csv')">Copy CSV Header</button>
          </div>
        </div>
        ${sourceSchemaHtml ? `
        <div class="panel">
          <h3>Source Schemas</h3>
          ${sourceSchemaHtml}
        </div>` : ''}
        ${lastEventJson ? `
        <div class="panel">
          <h3>Latest Event</h3>
          <pre style="max-height:220px;overflow:auto;font-family:var(--mono);font-size:12px;border:1px solid rgba(62,120,178,0.2);border-radius:12px;padding:12px;background:rgba(7,10,16,0.95);color:#d9e3f5;">${escapeHtml(lastEventJson)}</pre>
        </div>` : ''}
        <div class="panel column-merge">
          <h3>Integration Snippets</h3>
          <div class="code-block">
            <button onclick="copySnippet('python-${stream.streamId}')">Copy</button>
            <pre><code id="python-${stream.streamId}"></code></pre>
          </div>
          <div class="code-block">
            <button onclick="copySnippet('ws-${stream.streamId}')">Copy</button>
            <pre><code id="ws-${stream.streamId}"></code></pre>
          </div>
          <div class="code-block">
            <button onclick="copySnippet('curl-${stream.streamId}')">Copy</button>
            <pre><code id="curl-${stream.streamId}"></code></pre>
          </div>
        </div>
        <div class="panel">
          <h3>Actions</h3>
          <div class="actions-list">
            <div class="action-btn" onclick="restartStream('${stream.streamId}')">Restart Stream</div>
            <div class="action-btn" onclick="duplicateStream('${stream.streamId}')">Duplicate Spec</div>
            <div class="action-btn" onclick="downloadSpec('${stream.streamId}')">Download Spec JSON</div>
            <div class="action-btn danger" onclick="stopStream('${stream.streamId}')">Stop Stream</div>
          </div>
        </div>
      `;

      const pythonSnippet = `from ekko import listen\n\nasync def main():\n    async for event in listen("${stream.streamId}"):\n        print(event)`;
      const wsActual = stream.wsUrl.replace('localhost', window.location.hostname);
      const wsDisplay = wsActual.replace(/token=.*$/i, 'token=***');
      const curlSnippet = `curl -X GET "https://api.bond.dev/v1/streams/${stream.streamId}" \\\n     -H "Authorization: Bearer <token>"`;

      setSnippet(`python-${stream.streamId}`, 'python', pythonSnippet);
      setSnippet(`ws-${stream.streamId}`, 'url', wsActual, wsDisplay);
      setSnippet(`curl-${stream.streamId}`, 'shell', curlSnippet);

    }

    function copySchema(streamId, type) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      const schema = getDisplaySchema(entry);
      if (!schema || !Object.keys(schema).length) return;
      if (type === 'json') {
        navigator.clipboard.writeText(JSON.stringify(schema, null, 2));
      } else {
        navigator.clipboard.writeText(Object.keys(schema).join(','));
      }
    }

    function highlightSnippet(lang, code) {
      let escaped = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      const apply = (regex, cls) => {
        escaped = escaped.replace(regex, `<span class="${cls}">$1</span>`);
      };

      if (lang === 'python') {
        apply(/\b(async|await|for|in|from|import|print|return|def|class|with|as|yield|if|else|elif)\b/g, 'kw');
        apply(/\b(True|False|None)\b/g, 'const');
        apply(/(&quot;.*?&quot;)/g, 'str');
        apply(/(&#39;.*?&#39;)/g, 'str');
        apply(/(#.*?$)/gm, 'comment');
      } else if (lang === 'shell') {
        apply(/^(curl)/gm, 'cmd');
        apply(/\s(-{1,2}\w+)/g, 'flag');
        apply(/(https?:\/\/[^\s]+)/g, 'str');
        apply(/(".*?")/g, 'str');
      } else if (lang === 'url') {
        apply(/(wss?:\/\/[^\s]+)/g, 'str');
        apply(/(token=)([^\s]+)/g, 'flag');
      }

      escaped = escaped
        .replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
        .replace(/  /g, '&nbsp;&nbsp;')
        .replace(/\n/g, '<br>');

      return escaped;
    }

    function setSnippet(elementId, lang, code, displayCode = null) {
      const node = document.getElementById(elementId);
      if (!node) return;
      node.dataset.snippet = code;
      const toRender = displayCode == null ? code : displayCode;
      node.innerHTML = highlightSnippet(lang, toRender);
    }

    function copySnippet(elementId) {
      const node = document.getElementById(elementId);
      if (!node) return;
      const text = node.dataset.snippet || node.innerText || '';
      navigator.clipboard.writeText(text);
    }

    function extractRepresentativePrice(event) {
      if (!event) return null;
      if (typeof event.price_close === 'number') return event.price_close;
      if (typeof event.price_avg === 'number') return event.price_avg;
      const exchangeData = event.raw_data?.exchange_data;
      if (exchangeData) {
        for (const exchange of Object.keys(exchangeData)) {
          const symbols = exchangeData[exchange]?.symbols || {};
          for (const symbol of Object.keys(symbols)) {
            const price = symbols[symbol]?.price;
            if (typeof price === 'number') return price;
          }
        }
      }
      return null;
    }

    const MARKET_ONLY_FIELDS = new Set([
      'price_avg', 'price_high', 'price_low', 'price_open', 'price_close',
      'bid_avg', 'ask_avg', 'bid_volume', 'ask_volume',
      'volume_sum', 'volume_base_sum',
      'onchain_count', 'onchain_value_sum',
      'custom_count'
    ]);

    const SOURCE_SCHEMA_DEFS = {
      ccxt: [
        { name: 'ts', type: 'timestamp', description: 'Event timestamp (UTC)' },
        { name: 'window_start', type: 'timestamp', description: 'Window start for aggregation' },
        { name: 'window_end', type: 'timestamp', description: 'Window end for aggregation' },
        { name: 'price_open', type: 'float', description: 'First trade price in window' },
        { name: 'price_high', type: 'float', description: 'Highest trade price in window' },
        { name: 'price_low', type: 'float', description: 'Lowest trade price in window' },
        { name: 'price_close', type: 'float', description: 'Last trade price in window' },
        { name: 'price_avg', type: 'float', description: 'VWAP for the window' },
        { name: 'volume_sum', type: 'float', description: 'Total traded quote volume' },
        { name: 'raw_data.exchange_data', type: 'object', description: 'Per-exchange book/trade payloads' }
      ],
      nitter: [
        { name: 'ts', type: 'timestamp', description: 'Ingestion timestamp' },
        { name: 'tweets', type: 'int', description: 'Tweets observed in window' },
        { name: 'raw_data.tweet_data.text', type: 'string', description: 'Tweet text' },
        { name: 'raw_data.tweet_data.timestamp_posted', type: 'string', description: 'Original tweet timestamp' },
        { name: 'raw_data.tweet_data.stats', type: 'string', description: 'Like/retweet/reply stats' },
        { name: 'raw_data.tweet_data.symbol', type: 'string', description: 'Handle or symbol extracted' },
        { name: 'raw_data.tweet_data.event_type', type: 'string', description: 'Event type, e.g. tweet' }
      ],
      google_trends: [
        { name: 'ts', type: 'timestamp', description: 'Collection timestamp' },
        { name: 'raw_data.keyword', type: 'string', description: 'Keyword tracked' },
        { name: 'raw_data.score', type: 'int', description: 'Relative interest score' },
        { name: 'raw_data.geo', type: 'string', description: 'Region (if specified)' }
      ]
    };

    function deriveSchemaFromEvent(event) {
      if (!event || typeof event !== 'object') return null;
      const result = {};
      for (const [key, value] of Object.entries(event)) {
        result[key] = inferType(value);
      }
      return result;
    }

    function normalizeSchemaDict(schema) {
      if (!schema) return null;
      if (Array.isArray(schema)) {
        const map = {};
        for (const field of schema) {
          if (!field || typeof field !== 'object' || !field.name) continue;
          const meta = {};
          if (field.type) meta.type = field.type;
          if (field.optional != null) meta.optional = Boolean(field.optional);
          if (field.description) meta.description = field.description;
          map[field.name] = Object.keys(meta).length ? meta : 'any';
        }
        return Object.keys(map).length ? map : null;
      }
      if (schema.fields && Array.isArray(schema.fields)) {
        return normalizeSchemaDict(schema.fields);
      }
      if (typeof schema === 'object') {
        const map = {};
        for (const [key, value] of Object.entries(schema)) {
          if (key === 'stream_id') continue;
          if (key === 'fields' && Array.isArray(value)) {
            const nested = normalizeSchemaDict(value);
            if (nested) Object.assign(map, nested);
            continue;
          }
          map[key] = value;
        }
        return Object.keys(map).length ? map : null;
      }
      return null;
    }

    function collectSourceSchemaUnion(stream) {
      const union = {};
      if (!stream?.spec?.sources) return union;
      for (const source of stream.spec.sources) {
        const defs = SOURCE_SCHEMA_DEFS[source.type];
        if (!defs) continue;
        for (const field of defs) {
          union[field.name] = {
            type: field.type,
            optional: field.optional ?? false,
            description: field.description,
          };
        }
      }
      return union;
    }

    function inferType(value) {
      if (value === null || value === undefined) return { type: 'unknown', optional: true };
      if (typeof value === 'number') {
        return { type: Number.isInteger(value) ? 'int' : 'float' };
      }
      if (typeof value === 'string') return { type: 'string' };
      if (typeof value === 'boolean') return { type: 'bool' };
      if (Array.isArray(value)) return { type: 'array' };
      if (value instanceof Date) return { type: 'datetime' };
      if (typeof value === 'object') {
        return { type: 'object', optional: false };
      }
      return { type: typeof value };
    }

    function describeSourceTitle(source, stream) {
      if (!source) return 'Source';
      if (source.type === 'ccxt') {
        const exchange = (source.exchange || 'binanceus').toUpperCase();
        const symbols = (source.symbols && source.symbols.length ? source.symbols : stream.spec?.symbols || []).join(', ');
        return `CCXT · ${exchange}${symbols ? ` · ${symbols}` : ''}`;
      }
      if (source.type === 'nitter') {
        return `Nitter · @${source.username || 'elonmusk'}`;
      }
      if (source.type === 'google_trends') {
        const keywords = (source.keywords || []).join(', ');
        return keywords ? `Google Trends · ${keywords}` : 'Google Trends';
      }
      return source.type.toUpperCase();
    }

    function renderSourceSchemaBlocks(stream) {
      const sources = stream.spec?.sources || [];
      const blocks = [];
      for (const source of sources) {
        const defs = SOURCE_SCHEMA_DEFS[source.type];
        if (!defs || !defs.length) continue;
        const rows = defs.map(field => `
          <div class="source-schema-field">
            <span>${escapeHtml(field.name)}</span>
            <span>${escapeHtml(field.type)}${field.description ? ` · ${escapeHtml(field.description)}` : ''}</span>
          </div>
        `).join('');
        blocks.push(`
          <div class="source-schema-block">
            <div class="source-schema-title">${escapeHtml(describeSourceTitle(source, stream))}</div>
            <div class="source-schema-grid">
              ${rows}
            </div>
          </div>
        `);
      }
      return blocks.join('');
    }

    function getDisplaySchema(stream) {
      const normalized = normalizeSchemaDict(stream.schema);
      const base = normalized && Object.keys(normalized).length ? normalized : {};
      const derived = stream.derivedSchema || {};
      const combined = { ...base, ...derived };
      const entries = Object.entries(combined);
      const filtered = {};
      const eventKeys = stream.lastEvent ? new Set(Object.keys(stream.lastEvent)) : null;
      const hasCcxtSource = (stream.spec?.sources || []).some(src => src.type === 'ccxt');

      for (const [field, meta] of entries) {
        if (eventKeys && !eventKeys.has(field)) continue;
        filtered[field] = meta;
      }

      let candidate;
      if (Object.keys(filtered).length) {
        candidate = filtered;
      } else if (Object.keys(derived).length) {
        candidate = { ...derived };
      } else {
        candidate = { ...combined };
      }

      if (!hasCcxtSource) {
        for (const field of Object.keys(candidate)) {
          if (MARKET_ONLY_FIELDS.has(field)) {
            delete candidate[field];
          }
        }
      }

      if (!Object.keys(candidate).length) {
        const union = collectSourceSchemaUnion(stream);
        if (Object.keys(union).length) {
          Object.assign(candidate, union);
        }
      }

      if ((!candidate.symbol) && ((stream.spec?.symbols || []).length > 1 || stream.lastEvent?.symbol)) {
        candidate.symbol = { type: 'string' };
      }

      return Object.keys(candidate).length ? candidate : null;
    }

    function formatDuration(milliseconds) {
      if (!Number.isFinite(milliseconds) || milliseconds < 0) return null;
      const totalSeconds = Math.floor(milliseconds / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      const parts = [];
      if (hours) parts.push(`${hours}h`);
      if (minutes) parts.push(`${minutes}m`);
      if (!parts.length || seconds) parts.push(`${seconds}s`);
      return parts.join(' ');
    }

    async function refreshMetrics(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch(`/v1/streams/${streamId}/metrics`);
        if (!response.ok) throw new Error(await response.text());
        entry.metrics = await response.json();
        renderStreamDetail(entry);
      } catch (err) {
        appendMessage('agent', `Unable to refresh metrics: ${escapeHtml(err.message)}`);
      }
    }

    async function restartStream(streamId) {
      try {
        const response = await fetch(`/v1/streams/${streamId}/restart`, { method: 'PATCH' });
        if (!response.ok) throw new Error(await response.text());
        const stream = await response.json();
        applyStreamResponse(stream);
        appendMessage('agent', `Stream ${escapeHtml(streamId)} restarted.`);
      } catch (err) {
        appendMessage('agent', `Restart failed: ${escapeHtml(err.message)}`);
      }
    }

    async function duplicateStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch('/v1/streams', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ spec: cloneSpec(entry.spec) }),
        });
        if (!response.ok) throw new Error(await response.text());
        const stream = await response.json();
        appendMessage('agent', `Duplicated stream as <code>${escapeHtml(stream.stream_id)}</code>.`);
        addSession(stream.stream_id, stream.ws_url, stream.spec);
        loadStream(stream.stream_id);
      } catch (err) {
        appendMessage('agent', `Duplicate failed: ${escapeHtml(err.message)}`);
      }
    }

    async function downloadSpec(streamId) {
      try {
        const response = await fetch(`/v1/streams/${streamId}/spec`);
        if (!response.ok) throw new Error(await response.text());
        const spec = await response.json();
        const blob = new Blob([JSON.stringify(spec, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${streamId}_spec.json`;
        link.click();
        URL.revokeObjectURL(url);
      } catch (err) {
        appendMessage('agent', `Spec download failed: ${escapeHtml(err.message)}`);
      }
    }

    async function stopStream(streamId) {
      const entry = activeStreams.get(streamId);
      if (!entry) return;
      try {
        const response = await fetch(`/v1/streams/${streamId}`, { method: 'DELETE' });
        if (!response.ok) throw new Error(await response.text());
        appendMessage('agent', `Stream ${escapeHtml(streamId)} stopped.`);
        if (entry.socket) {
          entry.socket.close();
          entry.socket = null;
        }
        const removedWasCurrent = streamId === currentStreamId;
        activeStreams.delete(streamId);
        cancelPoll(streamId);
        if (removedWasCurrent) {
          currentStreamId = null;
          detailBody.innerHTML = '<div class="panel column-merge" style="text-align:center;opacity:0.6;"><h3>Stream stopped</h3><p style="font-size:13px;color:var(--text-muted);">Select another stream or launch a new one.</p></div>';
          streamStatus.style.display = 'none';
        }
        renderSessions();
        if (removedWasCurrent) {
          setView(activeStreams.size ? VIEW_STREAMS : VIEW_CHAT);
        }
      } catch (err) {
        appendMessage('agent', `Failed to stop stream: ${escapeHtml(err.message)}`);
      }
    }

    document.addEventListener('keydown', (event) => {
      if (event.metaKey && event.key.toLowerCase() === 'n') {
        event.preventDefault();
        messageInput.focus();
      }
      if (event.metaKey && event.key.toLowerCase() === 'k') {
        event.preventDefault();
        pauseAll = !pauseAll;
        appendMessage('agent', pauseAll ? 'All streams paused (not yet implemented).' : 'Resume streams (not yet implemented).');
        setPauseButtonLabels();
      }
    });

    renderSessions();
    setView(VIEW_CHAT);

    appendMessage('agent', `Echo Agent ready.
    <div style="margin-top:12px;font-size:12px;color:var(--text-muted);">
      Try: "Stream BTC/USDT every 5 seconds."
      <br/>Move over to Streams whenever you want to inspect or tweak an active feed.
    </div>`);
  </script>

  <!-- Supabase Auth -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = 'https://eezdrsmjpycrzuriyzni.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVlemRyc21qcHljcnp1cml5em5pIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI1MDQ1NTgsImV4cCI6MjA3ODA4MDU1OH0.kBl6L1pnX1OnNbTYURcNfijIK8Oqq4xfjXECwLLm_4o';

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const authStatus = document.getElementById('auth-status');
    const loginLink = document.getElementById('login-link');
    const userEmailDisplay = document.getElementById('user-email-display');
    const logoutBtn = document.getElementById('logout-btn');

    // Check auth status on page load
    async function checkAuthStatus() {
      const { data: { session } } = await supabase.auth.getSession();

      if (session) {
        // User is logged in
        userEmailDisplay.textContent = session.user.email;
        authStatus.style.display = 'flex';
        loginLink.style.display = 'none';
      } else {
        // User is not logged in
        authStatus.style.display = 'none';
        loginLink.style.display = 'inline-flex';
      }
    }

    // Handle logout
    if (logoutBtn) {
      logoutBtn.addEventListener('click', async () => {
        await supabase.auth.signOut();
        window.location.href = '/login';
      });
    }

    // Initialize auth status
    checkAuthStatus();

    // Listen for auth changes
    supabase.auth.onAuthStateChange((event, session) => {
      checkAuthStatus();
    });
  </script>
</body>
</html>
